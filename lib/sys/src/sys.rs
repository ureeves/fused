/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const FUSE_OPT_KEY_OPT: i32 = -1;
pub const FUSE_OPT_KEY_NONOPT: i32 = -2;
pub const FUSE_OPT_KEY_KEEP: i32 = -3;
pub const FUSE_OPT_KEY_DISCARD: i32 = -4;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const FUSE_MAJOR_VERSION: u32 = 3;
pub const FUSE_MINOR_VERSION: u32 = 12;
pub const FUSE_CAP_ASYNC_READ: u32 = 1;
pub const FUSE_CAP_POSIX_LOCKS: u32 = 2;
pub const FUSE_CAP_ATOMIC_O_TRUNC: u32 = 8;
pub const FUSE_CAP_EXPORT_SUPPORT: u32 = 16;
pub const FUSE_CAP_DONT_MASK: u32 = 64;
pub const FUSE_CAP_SPLICE_WRITE: u32 = 128;
pub const FUSE_CAP_SPLICE_MOVE: u32 = 256;
pub const FUSE_CAP_SPLICE_READ: u32 = 512;
pub const FUSE_CAP_FLOCK_LOCKS: u32 = 1024;
pub const FUSE_CAP_IOCTL_DIR: u32 = 2048;
pub const FUSE_CAP_AUTO_INVAL_DATA: u32 = 4096;
pub const FUSE_CAP_READDIRPLUS: u32 = 8192;
pub const FUSE_CAP_READDIRPLUS_AUTO: u32 = 16384;
pub const FUSE_CAP_ASYNC_DIO: u32 = 32768;
pub const FUSE_CAP_WRITEBACK_CACHE: u32 = 65536;
pub const FUSE_CAP_NO_OPEN_SUPPORT: u32 = 131072;
pub const FUSE_CAP_PARALLEL_DIROPS: u32 = 262144;
pub const FUSE_CAP_POSIX_ACL: u32 = 524288;
pub const FUSE_CAP_HANDLE_KILLPRIV: u32 = 1048576;
pub const FUSE_CAP_CACHE_SYMLINKS: u32 = 8388608;
pub const FUSE_CAP_NO_OPENDIR_SUPPORT: u32 = 16777216;
pub const FUSE_CAP_EXPLICIT_INVAL_DATA: u32 = 33554432;
pub const FUSE_IOCTL_COMPAT: u32 = 1;
pub const FUSE_IOCTL_UNRESTRICTED: u32 = 2;
pub const FUSE_IOCTL_RETRY: u32 = 4;
pub const FUSE_IOCTL_DIR: u32 = 16;
pub const FUSE_IOCTL_MAX_IOV: u32 = 256;
pub const _UTIME_H: u32 = 1;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SYS_STAT_H: u32 = 1;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const _SYS_STATVFS_H: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const FUSE_ROOT_ID: u32 = 1;
pub const FUSE_SET_ATTR_MODE: u32 = 1;
pub const FUSE_SET_ATTR_UID: u32 = 2;
pub const FUSE_SET_ATTR_GID: u32 = 4;
pub const FUSE_SET_ATTR_SIZE: u32 = 8;
pub const FUSE_SET_ATTR_ATIME: u32 = 16;
pub const FUSE_SET_ATTR_MTIME: u32 = 32;
pub const FUSE_SET_ATTR_ATIME_NOW: u32 = 128;
pub const FUSE_SET_ATTR_MTIME_NOW: u32 = 256;
pub const FUSE_SET_ATTR_CTIME: u32 = 1024;
pub const CUSE_UNRESTRICTED_IOCTL: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const FUSE_KERNEL_VERSION: u32 = 7;
pub const FUSE_KERNEL_MINOR_VERSION: u32 = 31;
pub const FATTR_MODE: u32 = 1;
pub const FATTR_UID: u32 = 2;
pub const FATTR_GID: u32 = 4;
pub const FATTR_SIZE: u32 = 8;
pub const FATTR_ATIME: u32 = 16;
pub const FATTR_MTIME: u32 = 32;
pub const FATTR_FH: u32 = 64;
pub const FATTR_ATIME_NOW: u32 = 128;
pub const FATTR_MTIME_NOW: u32 = 256;
pub const FATTR_LOCKOWNER: u32 = 512;
pub const FATTR_CTIME: u32 = 1024;
pub const FOPEN_DIRECT_IO: u32 = 1;
pub const FOPEN_KEEP_CACHE: u32 = 2;
pub const FOPEN_NONSEEKABLE: u32 = 4;
pub const FOPEN_CACHE_DIR: u32 = 8;
pub const FOPEN_STREAM: u32 = 16;
pub const FOPEN_NOFLUSH: u32 = 32;
pub const FUSE_ASYNC_READ: u32 = 1;
pub const FUSE_POSIX_LOCKS: u32 = 2;
pub const FUSE_FILE_OPS: u32 = 4;
pub const FUSE_ATOMIC_O_TRUNC: u32 = 8;
pub const FUSE_EXPORT_SUPPORT: u32 = 16;
pub const FUSE_BIG_WRITES: u32 = 32;
pub const FUSE_DONT_MASK: u32 = 64;
pub const FUSE_SPLICE_WRITE: u32 = 128;
pub const FUSE_SPLICE_MOVE: u32 = 256;
pub const FUSE_SPLICE_READ: u32 = 512;
pub const FUSE_FLOCK_LOCKS: u32 = 1024;
pub const FUSE_HAS_IOCTL_DIR: u32 = 2048;
pub const FUSE_AUTO_INVAL_DATA: u32 = 4096;
pub const FUSE_DO_READDIRPLUS: u32 = 8192;
pub const FUSE_READDIRPLUS_AUTO: u32 = 16384;
pub const FUSE_ASYNC_DIO: u32 = 32768;
pub const FUSE_WRITEBACK_CACHE: u32 = 65536;
pub const FUSE_NO_OPEN_SUPPORT: u32 = 131072;
pub const FUSE_PARALLEL_DIROPS: u32 = 262144;
pub const FUSE_HANDLE_KILLPRIV: u32 = 524288;
pub const FUSE_POSIX_ACL: u32 = 1048576;
pub const FUSE_ABORT_ERROR: u32 = 2097152;
pub const FUSE_MAX_PAGES: u32 = 4194304;
pub const FUSE_CACHE_SYMLINKS: u32 = 8388608;
pub const FUSE_NO_OPENDIR_SUPPORT: u32 = 16777216;
pub const FUSE_EXPLICIT_INVAL_DATA: u32 = 33554432;
pub const FUSE_MAP_ALIGNMENT: u32 = 67108864;
pub const FUSE_SUBMOUNTS: u32 = 134217728;
pub const FUSE_HANDLE_KILLPRIV_V2: u32 = 268435456;
pub const FUSE_SETXATTR_EXT: u32 = 536870912;
pub const FUSE_INIT_EXT: u32 = 1073741824;
pub const FUSE_INIT_RESERVED: u32 = 2147483648;
pub const FUSE_SECURITY_CTX: u64 = 4294967296;
pub const FUSE_HAS_INODE_DAX: u64 = 8589934592;
pub const FUSE_RELEASE_FLUSH: u32 = 1;
pub const FUSE_RELEASE_FLOCK_UNLOCK: u32 = 2;
pub const FUSE_GETATTR_FH: u32 = 1;
pub const FUSE_LK_FLOCK: u32 = 1;
pub const FUSE_WRITE_CACHE: u32 = 1;
pub const FUSE_WRITE_LOCKOWNER: u32 = 2;
pub const FUSE_WRITE_KILL_PRIV: u32 = 4;
pub const FUSE_READ_LOCKOWNER: u32 = 2;
pub const FUSE_IOCTL_32BIT: u32 = 8;
pub const FUSE_IOCTL_COMPAT_X32: u32 = 32;
pub const FUSE_POLL_SCHEDULE_NOTIFY: u32 = 1;
pub const FUSE_FSYNC_FDATASYNC: u32 = 1;
pub const FUSE_MIN_READ_BUFFER: u32 = 8192;
pub const FUSE_COMPAT_ENTRY_OUT_SIZE: u32 = 120;
pub const FUSE_COMPAT_ATTR_OUT_SIZE: u32 = 96;
pub const FUSE_COMPAT_MKNOD_IN_SIZE: u32 = 8;
pub const FUSE_COMPAT_WRITE_IN_SIZE: u32 = 24;
pub const FUSE_COMPAT_STATFS_SIZE: u32 = 48;
pub const FUSE_COMPAT_INIT_OUT_SIZE: u32 = 8;
pub const FUSE_COMPAT_22_INIT_OUT_SIZE: u32 = 24;
pub const CUSE_INIT_INFO_MAX: u32 = 4096;
#[doc = " Option description"]
#[doc = ""]
#[doc = " This structure describes a single option, and action associated"]
#[doc = " with it, in case it matches."]
#[doc = ""]
#[doc = " More than one such match may occur, in which case the action for"]
#[doc = " each match is executed."]
#[doc = ""]
#[doc = " There are three possible actions in case of a match:"]
#[doc = ""]
#[doc = " i) An integer (int or unsigned) variable determined by 'offset' is"]
#[doc = "    set to 'value'"]
#[doc = ""]
#[doc = " ii) The processing function is called, with 'value' as the key"]
#[doc = ""]
#[doc = " iii) An integer (any) or string (char *) variable determined by"]
#[doc = "    'offset' is set to the value of an option parameter"]
#[doc = ""]
#[doc = " 'offset' should normally be either set to"]
#[doc = ""]
#[doc = "  - 'offsetof(struct foo, member)'  actions i) and iii)"]
#[doc = ""]
#[doc = "  - -1\t\t\t      action ii)"]
#[doc = ""]
#[doc = " The 'offsetof()' macro is defined in the <stddef.h> header."]
#[doc = ""]
#[doc = " The template determines which options match, and also have an"]
#[doc = " effect on the action.  Normally the action is either i) or ii), but"]
#[doc = " if a format is present in the template, then action iii) is"]
#[doc = " performed."]
#[doc = ""]
#[doc = " The types of templates are:"]
#[doc = ""]
#[doc = " 1) \"-x\", \"-foo\", \"--foo\", \"--foo-bar\", etc.\tThese match only"]
#[doc = "   themselves.  Invalid values are \"--\" and anything beginning"]
#[doc = "   with \"-o\""]
#[doc = ""]
#[doc = " 2) \"foo\", \"foo-bar\", etc.  These match \"-ofoo\", \"-ofoo-bar\" or"]
#[doc = "    the relevant option in a comma separated option list"]
#[doc = ""]
#[doc = " 3) \"bar=\", \"--foo=\", etc.  These are variations of 1) and 2)"]
#[doc = "    which have a parameter"]
#[doc = ""]
#[doc = " 4) \"bar=%s\", \"--foo=%lu\", etc.  Same matching as above but perform"]
#[doc = "    action iii)."]
#[doc = ""]
#[doc = " 5) \"-x \", etc.  Matches either \"-xparam\" or \"-x param\" as"]
#[doc = "    two separate arguments"]
#[doc = ""]
#[doc = " 6) \"-x %s\", etc.  Combination of 4) and 5)"]
#[doc = ""]
#[doc = " If the format is \"%s\", memory is allocated for the string unlike with"]
#[doc = " scanf().  The previous value (if non-NULL) stored at the this location is"]
#[doc = " freed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_opt {
    #[doc = " Matching template and optional parameter formatting"]
    pub templ: *const ::libc::c_char,
    #[doc = " Offset of variable within 'data' parameter of fuse_opt_parse()"]
    #[doc = " or -1"]
    pub offset: ::libc::c_ulong,
    #[doc = " Value to set the variable to, or to be passed as 'key' to the"]
    #[doc = " processing function.\t Ignored if template has a format"]
    pub value: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_fuse_opt() {
    assert_eq!(
        ::std::mem::size_of::<fuse_opt>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_opt))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_opt>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_opt))
    );
    fn test_field_templ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).templ) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_opt),
                "::",
                stringify!(templ)
            )
        );
    }
    test_field_templ();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_opt),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_opt>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_opt),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[doc = " Argument list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_args {
    #[doc = " Argument count"]
    pub argc: ::libc::c_int,
    #[doc = " Argument vector.  NULL terminated"]
    pub argv: *mut *mut ::libc::c_char,
    #[doc = " Is 'argv' allocated?"]
    pub allocated: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_fuse_args() {
    assert_eq!(
        ::std::mem::size_of::<fuse_args>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_args))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_args>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_args))
    );
    fn test_field_argc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_args>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_args),
                "::",
                stringify!(argc)
            )
        );
    }
    test_field_argc();
    fn test_field_argv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_args>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_args),
                "::",
                stringify!(argv)
            )
        );
    }
    test_field_argv();
    fn test_field_allocated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_args>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocated) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_args),
                "::",
                stringify!(allocated)
            )
        );
    }
    test_field_allocated();
}
#[doc = " Processing function"]
#[doc = ""]
#[doc = " This function is called if"]
#[doc = "    - option did not match any 'struct fuse_opt'"]
#[doc = "    - argument is a non-option"]
#[doc = "    - option did match and offset was set to -1"]
#[doc = ""]
#[doc = " The 'arg' parameter will always contain the whole argument or"]
#[doc = " option including the parameter if exists.  A two-argument option"]
#[doc = " (\"-x foo\") is always converted to single argument option of the"]
#[doc = " form \"-xfoo\" before this function is called."]
#[doc = ""]
#[doc = " Options of the form '-ofoo' are passed to this function without the"]
#[doc = " '-o' prefix."]
#[doc = ""]
#[doc = " The return value of this function determines whether this argument"]
#[doc = " is to be inserted into the output argument vector, or discarded."]
#[doc = ""]
#[doc = " @param data is the user data passed to the fuse_opt_parse() function"]
#[doc = " @param arg is the whole argument or option"]
#[doc = " @param key determines why the processing function was called"]
#[doc = " @param outargs the current output argument list"]
#[doc = " @return -1 on error, 0 if arg is to be discarded, 1 if arg should be kept"]
pub type fuse_opt_proc_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::libc::c_void,
        arg: *const ::libc::c_char,
        key: ::libc::c_int,
        outargs: *mut fuse_args,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " Option parsing function"]
    #[doc = ""]
    #[doc = " If 'args' was returned from a previous call to fuse_opt_parse() or"]
    #[doc = " it was constructed from"]
    #[doc = ""]
    #[doc = " A NULL 'args' is equivalent to an empty argument vector"]
    #[doc = ""]
    #[doc = " A NULL 'opts' is equivalent to an 'opts' array containing a single"]
    #[doc = " end marker"]
    #[doc = ""]
    #[doc = " A NULL 'proc' is equivalent to a processing function always"]
    #[doc = " returning '1'"]
    #[doc = ""]
    #[doc = " @param args is the input and output argument list"]
    #[doc = " @param data is the user data"]
    #[doc = " @param opts is the option description array"]
    #[doc = " @param proc is the processing function"]
    #[doc = " @return -1 on error, 0 on success"]
    pub fn fuse_opt_parse(
        args: *mut fuse_args,
        data: *mut ::libc::c_void,
        opts: *const fuse_opt,
        proc_: fuse_opt_proc_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Add an option to a comma separated option list"]
    #[doc = ""]
    #[doc = " @param opts is a pointer to an option list, may point to a NULL value"]
    #[doc = " @param opt is the option to add"]
    #[doc = " @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_add_opt(
        opts: *mut *mut ::libc::c_char,
        opt: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Add an option, escaping commas, to a comma separated option list"]
    #[doc = ""]
    #[doc = " @param opts is a pointer to an option list, may point to a NULL value"]
    #[doc = " @param opt is the option to add"]
    #[doc = " @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_add_opt_escaped(
        opts: *mut *mut ::libc::c_char,
        opt: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Add an argument to a NULL terminated argument vector"]
    #[doc = ""]
    #[doc = " @param args is the structure containing the current argument list"]
    #[doc = " @param arg is the new argument to add"]
    #[doc = " @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_add_arg(args: *mut fuse_args, arg: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Add an argument at the specified position in a NULL terminated"]
    #[doc = " argument vector"]
    #[doc = ""]
    #[doc = " Adds the argument to the N-th position.  This is useful for adding"]
    #[doc = " options at the beginning of the array which must not come after the"]
    #[doc = " special '--' option."]
    #[doc = ""]
    #[doc = " @param args is the structure containing the current argument list"]
    #[doc = " @param pos is the position at which to add the argument"]
    #[doc = " @param arg is the new argument to add"]
    #[doc = " @return -1 on allocation error, 0 on success"]
    pub fn fuse_opt_insert_arg(
        args: *mut fuse_args,
        pos: ::libc::c_int,
        arg: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Free the contents of argument list"]
    #[doc = ""]
    #[doc = " The structure itself is not freed"]
    #[doc = ""]
    #[doc = " @param args is the structure containing the argument list"]
    pub fn fuse_opt_free_args(args: *mut fuse_args);
}
extern "C" {
    #[doc = " Check if an option matches"]
    #[doc = ""]
    #[doc = " @param opts is the option description array"]
    #[doc = " @param opt is the option to match"]
    #[doc = " @return 1 if a match is found, 0 if not"]
    pub fn fuse_opt_match(opts: *const fuse_opt, opt: *const ::libc::c_char) -> ::libc::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub const fuse_log_level_FUSE_LOG_EMERG: fuse_log_level = 0;
pub const fuse_log_level_FUSE_LOG_ALERT: fuse_log_level = 1;
pub const fuse_log_level_FUSE_LOG_CRIT: fuse_log_level = 2;
pub const fuse_log_level_FUSE_LOG_ERR: fuse_log_level = 3;
pub const fuse_log_level_FUSE_LOG_WARNING: fuse_log_level = 4;
pub const fuse_log_level_FUSE_LOG_NOTICE: fuse_log_level = 5;
pub const fuse_log_level_FUSE_LOG_INFO: fuse_log_level = 6;
pub const fuse_log_level_FUSE_LOG_DEBUG: fuse_log_level = 7;
#[doc = " Log severity level"]
#[doc = ""]
#[doc = " These levels correspond to syslog(2) log levels since they are widely used."]
pub type fuse_log_level = ::libc::c_uint;
#[doc = " Log message handler function."]
#[doc = ""]
#[doc = " This function must be thread-safe.  It may be called from any libfuse"]
#[doc = " function, including fuse_parse_cmdline() and other functions invoked before"]
#[doc = " a FUSE filesystem is created."]
#[doc = ""]
#[doc = " Install a custom log message handler function using fuse_set_log_func()."]
#[doc = ""]
#[doc = " @param level log severity level"]
#[doc = " @param fmt sprintf-style format string including newline"]
#[doc = " @param ap format string arguments"]
pub type fuse_log_func_t = ::std::option::Option<
    unsafe extern "C" fn(level: fuse_log_level, fmt: *const ::libc::c_char, ap: *mut __va_list_tag),
>;
extern "C" {
    #[doc = " Install a custom log handler function."]
    #[doc = ""]
    #[doc = " Log messages are emitted by libfuse functions to report errors and debug"]
    #[doc = " information.  Messages are printed to stderr by default but this can be"]
    #[doc = " overridden by installing a custom log message handler function."]
    #[doc = ""]
    #[doc = " The log message handler function is global and affects all FUSE filesystems"]
    #[doc = " created within this process."]
    #[doc = ""]
    #[doc = " @param func a custom log message handler function or NULL to revert to"]
    #[doc = "             the default"]
    pub fn fuse_set_log_func(func: fuse_log_func_t);
}
extern "C" {
    #[doc = " Emit a log message"]
    #[doc = ""]
    #[doc = " @param level severity level (FUSE_LOG_ERR, FUSE_LOG_DEBUG, etc)"]
    #[doc = " @param fmt sprintf-style format string including newline"]
    pub fn fuse_log(level: fuse_log_level, fmt: *const ::libc::c_char, ...);
}
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __suseconds64_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type __sig_atomic_t = ::libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::libc::c_ulong;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field___fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(__fds_bits)
            )
        );
    }
    test_field___fds_bits();
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::libc::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::libc::c_uint,
    pub __high: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__atomic_wide_counter__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    fn test_field___value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value64)
            )
        );
    }
    test_field___value64();
    fn test_field___value32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__atomic_wide_counter>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__atomic_wide_counter),
                "::",
                stringify!(__value32)
            )
        );
    }
    test_field___value32();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_slist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_slist),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::libc::c_int,
    pub __count: ::libc::c_uint,
    pub __owner: ::libc::c_int,
    pub __nusers: ::libc::c_uint,
    pub __kind: ::libc::c_int,
    pub __spins: ::libc::c_short,
    pub __elision: ::libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::libc::c_uint,
    pub __writers: ::libc::c_uint,
    pub __wrphase_futex: ::libc::c_uint,
    pub __writers_futex: ::libc::c_uint,
    pub __pad3: ::libc::c_uint,
    pub __pad4: ::libc::c_uint,
    pub __cur_writer: ::libc::c_int,
    pub __shared: ::libc::c_int,
    pub __rwelision: ::libc::c_schar,
    pub __pad1: [::libc::c_uchar; 7usize],
    pub __pad2: ::libc::c_ulong,
    pub __flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    fn test_field___readers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__readers)
            )
        );
    }
    test_field___readers();
    fn test_field___writers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers)
            )
        );
    }
    test_field___writers();
    fn test_field___wrphase_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__wrphase_futex)
            )
        );
    }
    test_field___wrphase_futex();
    fn test_field___writers_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__writers_futex)
            )
        );
    }
    test_field___writers_futex();
    fn test_field___pad3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad3)
            )
        );
    }
    test_field___pad3();
    fn test_field___pad4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad4)
            )
        );
    }
    test_field___pad4();
    fn test_field___cur_writer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__cur_writer)
            )
        );
    }
    test_field___cur_writer();
    fn test_field___shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__shared)
            )
        );
    }
    test_field___shared();
    fn test_field___rwelision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__rwelision)
            )
        );
    }
    test_field___rwelision();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field___pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__pad2)
            )
        );
    }
    test_field___pad2();
    fn test_field___flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_rwlock_arch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_rwlock_arch_t),
                "::",
                stringify!(__flags)
            )
        );
    }
    test_field___flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::libc::c_uint; 2usize],
    pub __g_size: [::libc::c_uint; 2usize],
    pub __g1_orig_size: ::libc::c_uint,
    pub __wrefs: ::libc::c_uint,
    pub __g_signals: [::libc::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
pub type __tss_t = ::libc::c_uint;
pub type __thrd_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__once_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__once_flag),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
}
pub type pthread_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutexattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_condattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::libc::c_char; 56usize],
    pub __align: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_attr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::libc::c_char; 40usize],
    pub __align: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::libc::c_char; 48usize],
    pub __align: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::libc::c_char; 56usize],
    pub __align: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlock_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::libc::c_char; 8usize],
    pub __align: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_rwlockattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
pub type pthread_spinlock_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::libc::c_char; 32usize],
    pub __align: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrier_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrier_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::libc::c_char; 4usize],
    pub __align: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_barrierattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_barrierattr_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
#[doc = " Information about an open file."]
#[doc = ""]
#[doc = " File Handles are created by the open, opendir, and create methods and closed"]
#[doc = " by the release and releasedir methods.  Multiple file handles may be"]
#[doc = " concurrently open for the same file.  Generally, a client will create one"]
#[doc = " file handle per file descriptor, though in some cases multiple file"]
#[doc = " descriptors can share a single file handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_file_info {
    #[doc = " Open flags.\t Available in open() and release()"]
    pub flags: ::libc::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    #[doc = " File handle id.  May be filled in by filesystem in create,"]
    #[doc = " open, and opendir().  Available in most other file operations on the"]
    #[doc = " same file handle."]
    pub fh: u64,
    #[doc = " Lock owner id.  Available in locking operations and flush"]
    pub lock_owner: u64,
    #[doc = " Requested poll events.  Available in ->poll.  Only set on kernels"]
    #[doc = "which support it.  If unsupported, this field is set to zero."]
    pub poll_events: u32,
}
#[test]
fn bindgen_test_layout_fuse_file_info() {
    assert_eq!(
        ::std::mem::size_of::<fuse_file_info>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_file_info))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_file_info>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_file_info))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_info),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_info),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_info),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
    fn test_field_poll_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poll_events) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_info),
                "::",
                stringify!(poll_events)
            )
        );
    }
    test_field_poll_events();
}
impl fuse_file_info {
    #[inline]
    pub fn writepage(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_writepage(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_io(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_io(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keep_cache(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keep_cache(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flush(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonseekable(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonseekable(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flock_release(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flock_release(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cache_readdir(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cache_readdir(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn noflush(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noflush(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn padding(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_padding(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn padding2(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_padding2(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        writepage: ::libc::c_uint,
        direct_io: ::libc::c_uint,
        keep_cache: ::libc::c_uint,
        flush: ::libc::c_uint,
        nonseekable: ::libc::c_uint,
        flock_release: ::libc::c_uint,
        cache_readdir: ::libc::c_uint,
        noflush: ::libc::c_uint,
        padding: ::libc::c_uint,
        padding2: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let writepage: u32 = unsafe { ::std::mem::transmute(writepage) };
            writepage as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let direct_io: u32 = unsafe { ::std::mem::transmute(direct_io) };
            direct_io as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let keep_cache: u32 = unsafe { ::std::mem::transmute(keep_cache) };
            keep_cache as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flush: u32 = unsafe { ::std::mem::transmute(flush) };
            flush as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nonseekable: u32 = unsafe { ::std::mem::transmute(nonseekable) };
            nonseekable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let flock_release: u32 = unsafe { ::std::mem::transmute(flock_release) };
            flock_release as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cache_readdir: u32 = unsafe { ::std::mem::transmute(cache_readdir) };
            cache_readdir as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let noflush: u32 = unsafe { ::std::mem::transmute(noflush) };
            noflush as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let padding: u32 = unsafe { ::std::mem::transmute(padding) };
            padding as u64
        });
        __bindgen_bitfield_unit.set(32usize, 32u8, {
            let padding2: u32 = unsafe { ::std::mem::transmute(padding2) };
            padding2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_loop_config_v1 {
    #[doc = " whether to use separate device fds for each thread"]
    #[doc = " (may increase performance)"]
    pub clone_fd: ::libc::c_int,
    #[doc = " The maximum number of available worker threads before they"]
    #[doc = " start to get deleted when they become idle. If not"]
    #[doc = " specified, the default is 10."]
    #[doc = ""]
    #[doc = " Adjusting this has performance implications; a very small number"]
    #[doc = " of threads in the pool will cause a lot of thread creation and"]
    #[doc = " deletion overhead and performance may suffer. When set to 0, a new"]
    #[doc = " thread will be created to service every operation."]
    pub max_idle_threads: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_fuse_loop_config_v1() {
    assert_eq!(
        ::std::mem::size_of::<fuse_loop_config_v1>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_loop_config_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_loop_config_v1>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_loop_config_v1))
    );
    fn test_field_clone_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_loop_config_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clone_fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_loop_config_v1),
                "::",
                stringify!(clone_fd)
            )
        );
    }
    test_field_clone_fd();
    fn test_field_max_idle_threads() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_loop_config_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_idle_threads) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_loop_config_v1),
                "::",
                stringify!(max_idle_threads)
            )
        );
    }
    test_field_max_idle_threads();
}
#[doc = " Connection information, passed to the ->init() method"]
#[doc = ""]
#[doc = " Some of the elements are read-write, these can be changed to"]
#[doc = " indicate the value requested by the filesystem.  The requested"]
#[doc = " value must usually be smaller than the indicated value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_conn_info {
    #[doc = " Major version of the protocol (read-only)"]
    pub proto_major: ::libc::c_uint,
    #[doc = " Minor version of the protocol (read-only)"]
    pub proto_minor: ::libc::c_uint,
    #[doc = " Maximum size of the write buffer"]
    pub max_write: ::libc::c_uint,
    #[doc = " Maximum size of read requests. A value of zero indicates no"]
    #[doc = " limit. However, even if the filesystem does not specify a"]
    #[doc = " limit, the maximum size of read requests will still be"]
    #[doc = " limited by the kernel."]
    #[doc = ""]
    #[doc = " NOTE: For the time being, the maximum size of read requests"]
    #[doc = " must be set both here *and* passed to fuse_session_new()"]
    #[doc = " using the ``-o max_read=<n>`` mount option. At some point"]
    #[doc = " in the future, specifying the mount option will no longer"]
    #[doc = " be necessary."]
    pub max_read: ::libc::c_uint,
    #[doc = " Maximum readahead"]
    pub max_readahead: ::libc::c_uint,
    #[doc = " Capability flags that the kernel supports (read-only)"]
    pub capable: ::libc::c_uint,
    #[doc = " Capability flags that the filesystem wants to enable."]
    #[doc = ""]
    #[doc = " libfuse attempts to initialize this field with"]
    #[doc = " reasonable default values before calling the init() handler."]
    pub want: ::libc::c_uint,
    #[doc = " Maximum number of pending \"background\" requests. A"]
    #[doc = " background request is any type of request for which the"]
    #[doc = " total number is not limited by other means. As of kernel"]
    #[doc = " 4.8, only two types of requests fall into this category:"]
    #[doc = ""]
    #[doc = "   1. Read-ahead requests"]
    #[doc = "   2. Asynchronous direct I/O requests"]
    #[doc = ""]
    #[doc = " Read-ahead requests are generated (if max_readahead is"]
    #[doc = " non-zero) by the kernel to preemptively fill its caches"]
    #[doc = " when it anticipates that userspace will soon read more"]
    #[doc = " data."]
    #[doc = ""]
    #[doc = " Asynchronous direct I/O requests are generated if"]
    #[doc = " FUSE_CAP_ASYNC_DIO is enabled and userspace submits a large"]
    #[doc = " direct I/O request. In this case the kernel will internally"]
    #[doc = " split it up into multiple smaller requests and submit them"]
    #[doc = " to the filesystem concurrently."]
    #[doc = ""]
    #[doc = " Note that the following requests are *not* background"]
    #[doc = " requests: writeback requests (limited by the kernel's"]
    #[doc = " flusher algorithm), regular (i.e., synchronous and"]
    #[doc = " buffered) userspace read/write requests (limited to one per"]
    #[doc = " thread), asynchronous read requests (Linux's io_submit(2)"]
    #[doc = " call actually blocks, so these are also limited to one per"]
    #[doc = " thread)."]
    pub max_background: ::libc::c_uint,
    #[doc = " Kernel congestion threshold parameter. If the number of pending"]
    #[doc = " background requests exceeds this number, the FUSE kernel module will"]
    #[doc = " mark the filesystem as \"congested\". This instructs the kernel to"]
    #[doc = " expect that queued requests will take some time to complete, and to"]
    #[doc = " adjust its algorithms accordingly (e.g. by putting a waiting thread"]
    #[doc = " to sleep instead of using a busy-loop)."]
    pub congestion_threshold: ::libc::c_uint,
    #[doc = " When FUSE_CAP_WRITEBACK_CACHE is enabled, the kernel is responsible"]
    #[doc = " for updating mtime and ctime when write requests are received. The"]
    #[doc = " updated values are passed to the filesystem with setattr() requests."]
    #[doc = " However, if the filesystem does not support the full resolution of"]
    #[doc = " the kernel timestamps (nanoseconds), the mtime and ctime values used"]
    #[doc = " by kernel and filesystem will differ (and result in an apparent"]
    #[doc = " change of times after a cache flush)."]
    #[doc = ""]
    #[doc = " To prevent this problem, this variable can be used to inform the"]
    #[doc = " kernel about the timestamp granularity supported by the file-system."]
    #[doc = " The value should be power of 10.  The default is 1, i.e. full"]
    #[doc = " nano-second resolution. Filesystems supporting only second resolution"]
    #[doc = " should set this to 1000000000."]
    pub time_gran: ::libc::c_uint,
    #[doc = " For future use."]
    pub reserved: [::libc::c_uint; 22usize],
}
#[test]
fn bindgen_test_layout_fuse_conn_info() {
    assert_eq!(
        ::std::mem::size_of::<fuse_conn_info>(),
        128usize,
        concat!("Size of: ", stringify!(fuse_conn_info))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_conn_info>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_conn_info))
    );
    fn test_field_proto_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proto_major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(proto_major)
            )
        );
    }
    test_field_proto_major();
    fn test_field_proto_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proto_minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(proto_minor)
            )
        );
    }
    test_field_proto_minor();
    fn test_field_max_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_write) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(max_write)
            )
        );
    }
    test_field_max_write();
    fn test_field_max_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_read) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(max_read)
            )
        );
    }
    test_field_max_read();
    fn test_field_max_readahead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_readahead) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(max_readahead)
            )
        );
    }
    test_field_max_readahead();
    fn test_field_capable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(capable)
            )
        );
    }
    test_field_capable();
    fn test_field_want() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).want) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(want)
            )
        );
    }
    test_field_want();
    fn test_field_max_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_background) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(max_background)
            )
        );
    }
    test_field_max_background();
    fn test_field_congestion_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).congestion_threshold) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(congestion_threshold)
            )
        );
    }
    test_field_congestion_threshold();
    fn test_field_time_gran() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_gran) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(time_gran)
            )
        );
    }
    test_field_time_gran();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_conn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_conn_info),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Session"]
#[doc = ""]
#[doc = " This provides hooks for processing requests, and exiting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_pollhandle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_conn_info_opts {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " This function parses several command-line options that can be used"]
    #[doc = " to override elements of struct fuse_conn_info. The pointer returned"]
    #[doc = " by this function should be passed to the"]
    #[doc = " fuse_apply_conn_info_opts() method by the file system's init()"]
    #[doc = " handler."]
    #[doc = ""]
    #[doc = " Before using this function, think twice if you really want these"]
    #[doc = " parameters to be adjustable from the command line. In most cases,"]
    #[doc = " they should be determined by the file system internally."]
    #[doc = ""]
    #[doc = " The following options are recognized:"]
    #[doc = ""]
    #[doc = "   -o max_write=N         sets conn->max_write"]
    #[doc = "   -o max_readahead=N     sets conn->max_readahead"]
    #[doc = "   -o max_background=N    sets conn->max_background"]
    #[doc = "   -o congestion_threshold=N  sets conn->congestion_threshold"]
    #[doc = "   -o async_read          sets FUSE_CAP_ASYNC_READ in conn->want"]
    #[doc = "   -o sync_read           unsets FUSE_CAP_ASYNC_READ in conn->want"]
    #[doc = "   -o atomic_o_trunc      sets FUSE_CAP_ATOMIC_O_TRUNC in conn->want"]
    #[doc = "   -o no_remote_lock      Equivalent to -o no_remote_flock,no_remote_posix_lock"]
    #[doc = "   -o no_remote_flock     Unsets FUSE_CAP_FLOCK_LOCKS in conn->want"]
    #[doc = "   -o no_remote_posix_lock  Unsets FUSE_CAP_POSIX_LOCKS in conn->want"]
    #[doc = "   -o [no_]splice_write     (un-)sets FUSE_CAP_SPLICE_WRITE in conn->want"]
    #[doc = "   -o [no_]splice_move      (un-)sets FUSE_CAP_SPLICE_MOVE in conn->want"]
    #[doc = "   -o [no_]splice_read      (un-)sets FUSE_CAP_SPLICE_READ in conn->want"]
    #[doc = "   -o [no_]auto_inval_data  (un-)sets FUSE_CAP_AUTO_INVAL_DATA in conn->want"]
    #[doc = "   -o readdirplus=no        unsets FUSE_CAP_READDIRPLUS in conn->want"]
    #[doc = "   -o readdirplus=yes       sets FUSE_CAP_READDIRPLUS and unsets"]
    #[doc = "                            FUSE_CAP_READDIRPLUS_AUTO in conn->want"]
    #[doc = "   -o readdirplus=auto      sets FUSE_CAP_READDIRPLUS and"]
    #[doc = "                            FUSE_CAP_READDIRPLUS_AUTO in conn->want"]
    #[doc = "   -o [no_]async_dio        (un-)sets FUSE_CAP_ASYNC_DIO in conn->want"]
    #[doc = "   -o [no_]writeback_cache  (un-)sets FUSE_CAP_WRITEBACK_CACHE in conn->want"]
    #[doc = "   -o time_gran=N           sets conn->time_gran"]
    #[doc = ""]
    #[doc = " Known options will be removed from *args*, unknown options will be"]
    #[doc = " passed through unchanged."]
    #[doc = ""]
    #[doc = " @param args argument vector (input+output)"]
    #[doc = " @return parsed options"]
    pub fn fuse_parse_conn_info_opts(args: *mut fuse_args) -> *mut fuse_conn_info_opts;
}
extern "C" {
    #[doc = " This function applies the (parsed) parameters in *opts* to the"]
    #[doc = " *conn* pointer. It may modify the following fields: wants,"]
    #[doc = " max_write, max_readahead, congestion_threshold, max_background,"]
    #[doc = " time_gran. A field is only set (or unset) if the corresponding"]
    #[doc = " option has been explicitly set."]
    pub fn fuse_apply_conn_info_opts(opts: *mut fuse_conn_info_opts, conn: *mut fuse_conn_info);
}
extern "C" {
    #[doc = " Go into the background"]
    #[doc = ""]
    #[doc = " @param foreground if true, stay in the foreground"]
    #[doc = " @return 0 on success, -1 on failure"]
    pub fn fuse_daemonize(foreground: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the version of the library"]
    #[doc = ""]
    #[doc = " @return the version"]
    pub fn fuse_version() -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the full package version string of the library"]
    #[doc = ""]
    #[doc = " @return the package version"]
    pub fn fuse_pkgversion() -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " Destroy poll handle"]
    #[doc = ""]
    #[doc = " @param ph the poll handle"]
    pub fn fuse_pollhandle_destroy(ph: *mut fuse_pollhandle);
}
#[doc = " Buffer contains a file descriptor"]
#[doc = ""]
#[doc = " If this flag is set, the .fd field is valid, otherwise the"]
#[doc = " .mem fields is valid."]
pub const fuse_buf_flags_FUSE_BUF_IS_FD: fuse_buf_flags = 2;
#[doc = " Seek on the file descriptor"]
#[doc = ""]
#[doc = " If this flag is set then the .pos field is valid and is"]
#[doc = " used to seek to the given offset before performing"]
#[doc = " operation on file descriptor."]
pub const fuse_buf_flags_FUSE_BUF_FD_SEEK: fuse_buf_flags = 4;
#[doc = " Retry operation on file descriptor"]
#[doc = ""]
#[doc = " If this flag is set then retry operation on file descriptor"]
#[doc = " until .size bytes have been copied or an error or EOF is"]
#[doc = " detected."]
pub const fuse_buf_flags_FUSE_BUF_FD_RETRY: fuse_buf_flags = 8;
#[doc = " Buffer flags"]
pub type fuse_buf_flags = ::libc::c_uint;
#[doc = " Don't use splice(2)"]
#[doc = ""]
#[doc = " Always fall back to using read and write instead of"]
#[doc = " splice(2) to copy data from one file descriptor to another."]
#[doc = ""]
#[doc = " If this flag is not set, then only fall back if splice is"]
#[doc = " unavailable."]
pub const fuse_buf_copy_flags_FUSE_BUF_NO_SPLICE: fuse_buf_copy_flags = 2;
#[doc = " Force splice"]
#[doc = ""]
#[doc = " Always use splice(2) to copy data from one file descriptor"]
#[doc = " to another.  If splice is not available, return -EINVAL."]
pub const fuse_buf_copy_flags_FUSE_BUF_FORCE_SPLICE: fuse_buf_copy_flags = 4;
#[doc = " Try to move data with splice."]
#[doc = ""]
#[doc = " If splice is used, try to move pages from the source to the"]
#[doc = " destination instead of copying.  See documentation of"]
#[doc = " SPLICE_F_MOVE in splice(2) man page."]
pub const fuse_buf_copy_flags_FUSE_BUF_SPLICE_MOVE: fuse_buf_copy_flags = 8;
#[doc = " Don't block on the pipe when copying data with splice"]
#[doc = ""]
#[doc = " Makes the operations on the pipe non-blocking (if the pipe"]
#[doc = " is full or empty).  See SPLICE_F_NONBLOCK in the splice(2)"]
#[doc = " man page."]
pub const fuse_buf_copy_flags_FUSE_BUF_SPLICE_NONBLOCK: fuse_buf_copy_flags = 16;
#[doc = " Buffer copy flags"]
pub type fuse_buf_copy_flags = ::libc::c_uint;
#[doc = " Single data buffer"]
#[doc = ""]
#[doc = " Generic data buffer for I/O, extended attributes, etc...  Data may"]
#[doc = " be supplied as a memory pointer or as a file descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_buf {
    #[doc = " Size of data in bytes"]
    pub size: size_t,
    #[doc = " Buffer flags"]
    pub flags: fuse_buf_flags,
    #[doc = " Memory pointer"]
    #[doc = ""]
    #[doc = " Used unless FUSE_BUF_IS_FD flag is set."]
    pub mem: *mut ::libc::c_void,
    #[doc = " File descriptor"]
    #[doc = ""]
    #[doc = " Used if FUSE_BUF_IS_FD flag is set."]
    pub fd: ::libc::c_int,
    #[doc = " File position"]
    #[doc = ""]
    #[doc = " Used if FUSE_BUF_FD_SEEK flag is set."]
    pub pos: off_t,
}
#[test]
fn bindgen_test_layout_fuse_buf() {
    assert_eq!(
        ::std::mem::size_of::<fuse_buf>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_buf))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_buf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_buf),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_buf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_buf),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_buf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_buf),
                "::",
                stringify!(mem)
            )
        );
    }
    test_field_mem();
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_buf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_buf),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_buf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_buf),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
}
#[doc = " Data buffer vector"]
#[doc = ""]
#[doc = " An array of data buffers, each containing a memory pointer or a"]
#[doc = " file descriptor."]
#[doc = ""]
#[doc = " Allocate dynamically to add more than one buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_bufvec {
    #[doc = " Number of buffers in the array"]
    pub count: size_t,
    #[doc = " Index of current buffer within the array"]
    pub idx: size_t,
    #[doc = " Current offset within the current buffer"]
    pub off: size_t,
    #[doc = " Array of buffers"]
    pub buf: [fuse_buf; 1usize],
}
#[test]
fn bindgen_test_layout_fuse_bufvec() {
    assert_eq!(
        ::std::mem::size_of::<fuse_bufvec>(),
        64usize,
        concat!("Size of: ", stringify!(fuse_bufvec))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_bufvec>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_bufvec))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bufvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bufvec),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_idx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bufvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idx) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bufvec),
                "::",
                stringify!(idx)
            )
        );
    }
    test_field_idx();
    fn test_field_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bufvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bufvec),
                "::",
                stringify!(off)
            )
        );
    }
    test_field_off();
    fn test_field_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bufvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bufvec),
                "::",
                stringify!(buf)
            )
        );
    }
    test_field_buf();
}
extern "C" {
    #[doc = " Get total size of data in a fuse buffer vector"]
    #[doc = ""]
    #[doc = " @param bufv buffer vector"]
    #[doc = " @return size of data"]
    pub fn fuse_buf_size(bufv: *const fuse_bufvec) -> size_t;
}
extern "C" {
    #[doc = " Copy data from one buffer vector to another"]
    #[doc = ""]
    #[doc = " @param dst destination buffer vector"]
    #[doc = " @param src source buffer vector"]
    #[doc = " @param flags flags controlling the copy"]
    #[doc = " @return actual number of bytes copied or -errno on error"]
    pub fn fuse_buf_copy(
        dst: *mut fuse_bufvec,
        src: *mut fuse_bufvec,
        flags: fuse_buf_copy_flags,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Exit session on HUP, TERM and INT signals and ignore PIPE signal"]
    #[doc = ""]
    #[doc = " Stores session in a global variable.\t May only be called once per"]
    #[doc = " process until fuse_remove_signal_handlers() is called."]
    #[doc = ""]
    #[doc = " Once either of the POSIX signals arrives, the signal handler calls"]
    #[doc = " fuse_session_exit()."]
    #[doc = ""]
    #[doc = " @param se the session to exit"]
    #[doc = " @return 0 on success, -1 on failure"]
    #[doc = ""]
    #[doc = " See also:"]
    #[doc = " fuse_remove_signal_handlers()"]
    pub fn fuse_set_signal_handlers(se: *mut fuse_session) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Restore default signal handlers"]
    #[doc = ""]
    #[doc = " Resets global session.  After this fuse_set_signal_handlers() may"]
    #[doc = " be called again."]
    #[doc = ""]
    #[doc = " @param se the same session as given in fuse_set_signal_handlers()"]
    #[doc = ""]
    #[doc = " See also:"]
    #[doc = " fuse_set_signal_handlers()"]
    pub fn fuse_remove_signal_handlers(se: *mut fuse_session);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_loop_config {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create and set default config for fuse_session_loop_mt and fuse_loop_mt."]
    #[doc = ""]
    #[doc = " @return anonymous config struct"]
    pub fn fuse_loop_cfg_create() -> *mut fuse_loop_config;
}
extern "C" {
    #[doc = " Free the config data structure"]
    pub fn fuse_loop_cfg_destroy(config: *mut fuse_loop_config);
}
extern "C" {
    #[doc = " fuse_loop_config setter to set the number of max idle threads."]
    pub fn fuse_loop_cfg_set_idle_threads(config: *mut fuse_loop_config, value: ::libc::c_uint);
}
extern "C" {
    #[doc = " fuse_loop_config setter to set the number of max threads."]
    pub fn fuse_loop_cfg_set_max_threads(config: *mut fuse_loop_config, value: ::libc::c_uint);
}
extern "C" {
    #[doc = " fuse_loop_config setter to enable the clone_fd feature"]
    pub fn fuse_loop_cfg_set_clone_fd(config: *mut fuse_loop_config, value: ::libc::c_uint);
}
extern "C" {
    #[doc = " Convert old config to more recernt fuse_loop_config2"]
    #[doc = ""]
    #[doc = " @param config current config2 type"]
    #[doc = " @param v1_conf older config1 type (below FUSE API 312)"]
    pub fn fuse_loop_cfg_convert(config: *mut fuse_loop_config, v1_conf: *mut fuse_loop_config_v1);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _fuse_off_t_must_be_64bit_dummy_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout__fuse_off_t_must_be_64bit_dummy_struct() {
    assert_eq!(
        ::std::mem::size_of::<_fuse_off_t_must_be_64bit_dummy_struct>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_fuse_off_t_must_be_64bit_dummy_struct)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_fuse_off_t_must_be_64bit_dummy_struct>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_fuse_off_t_must_be_64bit_dummy_struct)
        )
    );
}
impl _fuse_off_t_must_be_64bit_dummy_struct {
    #[inline]
    pub fn _fuse_off_t_must_be_64bit(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__fuse_off_t_must_be_64bit(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _fuse_off_t_must_be_64bit: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let _fuse_off_t_must_be_64bit: u32 =
                unsafe { ::std::mem::transmute(_fuse_off_t_must_be_64bit) };
            _fuse_off_t_must_be_64bit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct utimbuf {
    pub actime: __time_t,
    pub modtime: __time_t,
}
#[test]
fn bindgen_test_layout_utimbuf() {
    assert_eq!(
        ::std::mem::size_of::<utimbuf>(),
        16usize,
        concat!("Size of: ", stringify!(utimbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<utimbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(utimbuf))
    );
    fn test_field_actime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<utimbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).actime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(utimbuf),
                "::",
                stringify!(actime)
            )
        );
    }
    test_field_actime();
    fn test_field_modtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<utimbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modtime) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(utimbuf),
                "::",
                stringify!(modtime)
            )
        );
    }
    test_field_modtime();
}
extern "C" {
    pub fn utime(__file: *const ::libc::c_char, __file_times: *const utimbuf) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::libc::c_short,
    pub l_whence: ::libc::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    fn test_field_l_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_type)
            )
        );
    }
    test_field_l_type();
    fn test_field_l_whence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_whence)
            )
        );
    }
    test_field_l_whence();
    fn test_field_l_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_start)
            )
        );
    }
    test_field_l_start();
    fn test_field_l_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_len)
            )
        );
    }
    test_field_l_len();
    fn test_field_l_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_pid)
            )
        );
    }
    test_field_l_pid();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field___pad0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(__pad0)
            )
        );
    }
    test_field___pad0();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_blksize)
            )
        );
    }
    test_field_st_blksize();
    fn test_field_st_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_blocks)
            )
        );
    }
    test_field_st_blocks();
    fn test_field_st_atim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_atim)
            )
        );
    }
    test_field_st_atim();
    fn test_field_st_mtim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mtim)
            )
        );
    }
    test_field_st_mtim();
    fn test_field_st_ctim() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ctim)
            )
        );
    }
    test_field_st_ctim();
    fn test_field___glibc_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(__glibc_reserved)
            )
        );
    }
    test_field___glibc_reserved();
}
extern "C" {
    pub fn fcntl(__fd: ::libc::c_int, __cmd: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn open(__file: *const ::libc::c_char, __oflag: ::libc::c_int, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __oflag: ::libc::c_int,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::libc::c_char, __mode: mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lockf(__fd: ::libc::c_int, __cmd: ::libc::c_int, __len: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::libc::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: ::libc::c_int, __offset: off_t, __len: off_t) -> ::libc::c_int;
}
extern "C" {
    pub fn stat(__file: *const ::libc::c_char, __buf: *mut stat) -> ::libc::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::libc::c_int, __buf: *mut stat) -> ::libc::c_int;
}
extern "C" {
    pub fn fstatat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __buf: *mut stat,
        __flag: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::libc::c_char, __buf: *mut stat) -> ::libc::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::libc::c_char, __mode: __mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::libc::c_char, __mode: __mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::libc::c_int, __mode: __mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fchmodat(
        __fd: ::libc::c_int,
        __file: *const ::libc::c_char,
        __mode: __mode_t,
        __flag: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::libc::c_char, __mode: __mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn mkdirat(
        __fd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __mode: __mode_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn mknod(__path: *const ::libc::c_char, __mode: __mode_t, __dev: __dev_t) -> ::libc::c_int;
}
extern "C" {
    pub fn mknodat(
        __fd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::libc::c_char, __mode: __mode_t) -> ::libc::c_int;
}
extern "C" {
    pub fn mkfifoat(
        __fd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __mode: __mode_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::libc::c_int,
        __path: *const ::libc::c_char,
        __times: *const timespec,
        __flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::libc::c_int, __times: *const timespec) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statvfs {
    pub f_bsize: ::libc::c_ulong,
    pub f_frsize: ::libc::c_ulong,
    pub f_blocks: __fsblkcnt_t,
    pub f_bfree: __fsblkcnt_t,
    pub f_bavail: __fsblkcnt_t,
    pub f_files: __fsfilcnt_t,
    pub f_ffree: __fsfilcnt_t,
    pub f_favail: __fsfilcnt_t,
    pub f_fsid: ::libc::c_ulong,
    pub f_flag: ::libc::c_ulong,
    pub f_namemax: ::libc::c_ulong,
    pub __f_spare: [::libc::c_int; 6usize],
}
#[test]
fn bindgen_test_layout_statvfs() {
    assert_eq!(
        ::std::mem::size_of::<statvfs>(),
        112usize,
        concat!("Size of: ", stringify!(statvfs))
    );
    assert_eq!(
        ::std::mem::align_of::<statvfs>(),
        8usize,
        concat!("Alignment of ", stringify!(statvfs))
    );
    fn test_field_f_bsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_bsize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_bsize)
            )
        );
    }
    test_field_f_bsize();
    fn test_field_f_frsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_frsize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_frsize)
            )
        );
    }
    test_field_f_frsize();
    fn test_field_f_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_blocks) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_blocks)
            )
        );
    }
    test_field_f_blocks();
    fn test_field_f_bfree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_bfree) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_bfree)
            )
        );
    }
    test_field_f_bfree();
    fn test_field_f_bavail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_bavail) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_bavail)
            )
        );
    }
    test_field_f_bavail();
    fn test_field_f_files() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_files) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_files)
            )
        );
    }
    test_field_f_files();
    fn test_field_f_ffree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_ffree) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_ffree)
            )
        );
    }
    test_field_f_ffree();
    fn test_field_f_favail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_favail) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_favail)
            )
        );
    }
    test_field_f_favail();
    fn test_field_f_fsid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_fsid) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_fsid)
            )
        );
    }
    test_field_f_fsid();
    fn test_field_f_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_flag) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_flag)
            )
        );
    }
    test_field_f_flag();
    fn test_field_f_namemax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f_namemax) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(f_namemax)
            )
        );
    }
    test_field_f_namemax();
    fn test_field___f_spare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<statvfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__f_spare) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(statvfs),
                "::",
                stringify!(__f_spare)
            )
        );
    }
    test_field___f_spare();
}
pub const ST_RDONLY: _bindgen_ty_1 = 1;
pub const ST_NOSUID: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = ::libc::c_uint;
extern "C" {
    pub fn statvfs(__file: *const ::libc::c_char, __buf: *mut statvfs) -> ::libc::c_int;
}
extern "C" {
    pub fn fstatvfs(__fildes: ::libc::c_int, __buf: *mut statvfs) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::libc::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    fn test_field_iov_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_base)
            )
        );
    }
    test_field_iov_base();
    fn test_field_iov_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    test_field_iov_len();
}
extern "C" {
    pub fn readv(__fd: ::libc::c_int, __iovec: *const iovec, __count: ::libc::c_int) -> ssize_t;
}
extern "C" {
    pub fn writev(__fd: ::libc::c_int, __iovec: *const iovec, __count: ::libc::c_int) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::libc::c_int,
        __iovec: *const iovec,
        __count: ::libc::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
#[doc = " Inode number type"]
pub type fuse_ino_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_req {
    _unused: [u8; 0],
}
#[doc = " Request pointer type"]
pub type fuse_req_t = *mut fuse_req;
#[doc = " Directory entry parameters supplied to fuse_reply_entry()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_entry_param {
    #[doc = " Unique inode number"]
    #[doc = ""]
    #[doc = " In lookup, zero means negative entry (from version 2.5)"]
    #[doc = " Returning ENOENT also means negative entry, but by setting zero"]
    #[doc = " ino the kernel may cache negative entries for entry_timeout"]
    #[doc = " seconds."]
    pub ino: fuse_ino_t,
    #[doc = " Generation number for this entry."]
    #[doc = ""]
    #[doc = " If the file system will be exported over NFS, the"]
    #[doc = " ino/generation pairs need to be unique over the file"]
    #[doc = " system's lifetime (rather than just the mount time). So if"]
    #[doc = " the file system reuses an inode after it has been deleted,"]
    #[doc = " it must assign a new, previously unused generation number"]
    #[doc = " to the inode at the same time."]
    #[doc = ""]
    pub generation: u64,
    #[doc = " Inode attributes."]
    #[doc = ""]
    #[doc = " Even if attr_timeout == 0, attr must be correct. For example,"]
    #[doc = " for open(), FUSE uses attr.st_size from lookup() to determine"]
    #[doc = " how many bytes to request. If this value is not correct,"]
    #[doc = " incorrect data will be returned."]
    pub attr: stat,
    #[doc = " Validity timeout (in seconds) for inode attributes. If"]
    #[doc = "attributes only change as a result of requests that come"]
    #[doc = "through the kernel, this should be set to a very large"]
    #[doc = "value."]
    pub attr_timeout: f64,
    #[doc = " Validity timeout (in seconds) for the name. If directory"]
    #[doc = "entries are changed/deleted only as a result of requests"]
    #[doc = "that come through the kernel, this should be set to a very"]
    #[doc = "large value."]
    pub entry_timeout: f64,
}
#[test]
fn bindgen_test_layout_fuse_entry_param() {
    assert_eq!(
        ::std::mem::size_of::<fuse_entry_param>(),
        176usize,
        concat!("Size of: ", stringify!(fuse_entry_param))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_entry_param>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_entry_param))
    );
    fn test_field_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_param),
                "::",
                stringify!(ino)
            )
        );
    }
    test_field_ino();
    fn test_field_generation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).generation) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_param),
                "::",
                stringify!(generation)
            )
        );
    }
    test_field_generation();
    fn test_field_attr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_param),
                "::",
                stringify!(attr)
            )
        );
    }
    test_field_attr();
    fn test_field_attr_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr_timeout) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_param),
                "::",
                stringify!(attr_timeout)
            )
        );
    }
    test_field_attr_timeout();
    fn test_field_entry_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_timeout) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_param),
                "::",
                stringify!(entry_timeout)
            )
        );
    }
    test_field_entry_timeout();
}
#[doc = " Additional context associated with requests."]
#[doc = ""]
#[doc = " Note that the reported client uid, gid and pid may be zero in some"]
#[doc = " situations. For example, if the FUSE file system is running in a"]
#[doc = " PID or user namespace but then accessed from outside the namespace,"]
#[doc = " there is no valid uid/pid/gid that could be reported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_ctx {
    #[doc = " User ID of the calling process"]
    pub uid: uid_t,
    #[doc = " Group ID of the calling process"]
    pub gid: gid_t,
    #[doc = " Thread ID of the calling process"]
    pub pid: pid_t,
    #[doc = " Umask of the calling process"]
    pub umask: mode_t,
}
#[test]
fn bindgen_test_layout_fuse_ctx() {
    assert_eq!(
        ::std::mem::size_of::<fuse_ctx>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_ctx))
    );
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ctx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ctx),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ctx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ctx),
                "::",
                stringify!(gid)
            )
        );
    }
    test_field_gid();
    fn test_field_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ctx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ctx),
                "::",
                stringify!(pid)
            )
        );
    }
    test_field_pid();
    fn test_field_umask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ctx>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umask) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ctx),
                "::",
                stringify!(umask)
            )
        );
    }
    test_field_umask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_forget_data {
    pub ino: fuse_ino_t,
    pub nlookup: u64,
}
#[test]
fn bindgen_test_layout_fuse_forget_data() {
    assert_eq!(
        ::std::mem::size_of::<fuse_forget_data>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_forget_data))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_forget_data>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_forget_data))
    );
    fn test_field_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_forget_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_forget_data),
                "::",
                stringify!(ino)
            )
        );
    }
    test_field_ino();
    fn test_field_nlookup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_forget_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlookup) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_forget_data),
                "::",
                stringify!(nlookup)
            )
        );
    }
    test_field_nlookup();
}
#[doc = " Low level filesystem operations"]
#[doc = ""]
#[doc = " Most of the methods (with the exception of init and destroy)"]
#[doc = " receive a request handle (fuse_req_t) as their first argument."]
#[doc = " This handle must be passed to one of the specified reply functions."]
#[doc = ""]
#[doc = " This may be done inside the method invocation, or after the call"]
#[doc = " has returned.  The request handle is valid until one of the reply"]
#[doc = " functions is called."]
#[doc = ""]
#[doc = " Other pointer arguments (name, fuse_file_info, etc) are not valid"]
#[doc = " after the call has returned, so if they are needed later, their"]
#[doc = " contents have to be copied."]
#[doc = ""]
#[doc = " In general, all methods are expected to perform any necessary"]
#[doc = " permission checking. However, a filesystem may delegate this task"]
#[doc = " to the kernel by passing the `default_permissions` mount option to"]
#[doc = " `fuse_session_new()`. In this case, methods will only be called if"]
#[doc = " the kernel's permission check has succeeded."]
#[doc = ""]
#[doc = " The filesystem sometimes needs to handle a return value of -ENOENT"]
#[doc = " from the reply function, which means, that the request was"]
#[doc = " interrupted, and the reply discarded.  For example if"]
#[doc = " fuse_reply_open() return -ENOENT means, that the release method for"]
#[doc = " this file will not be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_lowlevel_ops {
    #[doc = " Initialize filesystem"]
    #[doc = ""]
    #[doc = " This function is called when libfuse establishes"]
    #[doc = " communication with the FUSE kernel module. The file system"]
    #[doc = " should use this module to inspect and/or modify the"]
    #[doc = " connection parameters provided in the `conn` structure."]
    #[doc = ""]
    #[doc = " Note that some parameters may be overwritten by options"]
    #[doc = " passed to fuse_session_new() which take precedence over the"]
    #[doc = " values set in this handler."]
    #[doc = ""]
    #[doc = " There's no reply to this function"]
    #[doc = ""]
    #[doc = " @param userdata the user data passed to fuse_session_new()"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::libc::c_void, conn: *mut fuse_conn_info),
    >,
    #[doc = " Clean up filesystem."]
    #[doc = ""]
    #[doc = " Called on filesystem exit. When this method is called, the"]
    #[doc = " connection to the kernel may be gone already, so that eg. calls"]
    #[doc = " to fuse_lowlevel_notify_* will fail."]
    #[doc = ""]
    #[doc = " There's no reply to this function"]
    #[doc = ""]
    #[doc = " @param userdata the user data passed to fuse_session_new()"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::libc::c_void)>,
    #[doc = " Look up a directory entry by name and get its attributes."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_entry"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name the name to look up"]
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, parent: fuse_ino_t, name: *const ::libc::c_char),
    >,
    #[doc = " Forget about an inode"]
    #[doc = ""]
    #[doc = " This function is called when the kernel removes an inode"]
    #[doc = " from its internal caches."]
    #[doc = ""]
    #[doc = " The inode's lookup count increases by one for every call to"]
    #[doc = " fuse_reply_entry and fuse_reply_create. The nlookup parameter"]
    #[doc = " indicates by how much the lookup count should be decreased."]
    #[doc = ""]
    #[doc = " Inodes with a non-zero lookup count may receive request from"]
    #[doc = " the kernel even after calls to unlink, rmdir or (when"]
    #[doc = " overwriting an existing file) rename. Filesystems must handle"]
    #[doc = " such requests properly and it is recommended to defer removal"]
    #[doc = " of the inode until the lookup count reaches zero. Calls to"]
    #[doc = " unlink, rmdir or rename will be followed closely by forget"]
    #[doc = " unless the file or directory is open, in which case the"]
    #[doc = " kernel issues forget only after the release or releasedir"]
    #[doc = " calls."]
    #[doc = ""]
    #[doc = " Note that if a file system will be exported over NFS the"]
    #[doc = " inodes lifetime must extend even beyond forget. See the"]
    #[doc = " generation field in struct fuse_entry_param above."]
    #[doc = ""]
    #[doc = " On unmount the lookup count for all inodes implicitly drops"]
    #[doc = " to zero. It is not guaranteed that the file system will"]
    #[doc = " receive corresponding forget messages for the affected"]
    #[doc = " inodes."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_none"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param nlookup the number of lookups to forget"]
    pub forget:
        ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, nlookup: u64)>,
    #[doc = " Get file attributes."]
    #[doc = ""]
    #[doc = " If writeback caching is enabled, the kernel may have a"]
    #[doc = " better idea of a file's length than the FUSE file system"]
    #[doc = " (eg if there has been a write that extended the file size,"]
    #[doc = " but that has not yet been passed to the filesystem.n"]
    #[doc = ""]
    #[doc = " In this case, the st_size value provided by the file system"]
    #[doc = " will be ignored."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_attr"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi for future use, currently always NULL"]
    pub getattr: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, fi: *mut fuse_file_info),
    >,
    #[doc = " Set file attributes"]
    #[doc = ""]
    #[doc = " In the 'attr' argument only members indicated by the 'to_set'"]
    #[doc = " bitmask contain valid values.  Other members contain undefined"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits if the file"]
    #[doc = " size or owner is being changed."]
    #[doc = ""]
    #[doc = " If the setattr was invoked from the ftruncate() system call"]
    #[doc = " under Linux kernel versions 2.6.15 or later, the fi->fh will"]
    #[doc = " contain the value set by the open method or will be undefined"]
    #[doc = " if the open method didn't set any value.  Otherwise (not"]
    #[doc = " ftruncate call, or kernel version earlier than 2.6.15) the fi"]
    #[doc = " parameter will be NULL."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_attr"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param attr the attributes"]
    #[doc = " @param to_set bit mask of attributes which should be set"]
    #[doc = " @param fi file information, or NULL"]
    pub setattr: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            attr: *mut stat,
            to_set: ::libc::c_int,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Read symbolic link"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_readlink"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    pub readlink: ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t)>,
    #[doc = " Create file node"]
    #[doc = ""]
    #[doc = " Create a regular file, character device, block device, fifo or"]
    #[doc = " socket node."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_entry"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name to create"]
    #[doc = " @param mode file type and mode with which to create the new file"]
    #[doc = " @param rdev the device number (only valid if created file is a device)"]
    pub mknod: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            parent: fuse_ino_t,
            name: *const ::libc::c_char,
            mode: mode_t,
            rdev: dev_t,
        ),
    >,
    #[doc = " Create a directory"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_entry"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name to create"]
    #[doc = " @param mode with which to create the new file"]
    pub mkdir: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            parent: fuse_ino_t,
            name: *const ::libc::c_char,
            mode: mode_t,
        ),
    >,
    #[doc = " Remove a file"]
    #[doc = ""]
    #[doc = " If the file's inode's lookup count is non-zero, the file"]
    #[doc = " system is expected to postpone any removal of the inode"]
    #[doc = " until the lookup count reaches zero (see description of the"]
    #[doc = " forget function)."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name to remove"]
    pub unlink: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, parent: fuse_ino_t, name: *const ::libc::c_char),
    >,
    #[doc = " Remove a directory"]
    #[doc = ""]
    #[doc = " If the directory's inode's lookup count is non-zero, the"]
    #[doc = " file system is expected to postpone any removal of the"]
    #[doc = " inode until the lookup count reaches zero (see description"]
    #[doc = " of the forget function)."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name to remove"]
    pub rmdir: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, parent: fuse_ino_t, name: *const ::libc::c_char),
    >,
    #[doc = " Create a symbolic link"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_entry"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param link the contents of the symbolic link"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name to create"]
    pub symlink: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            link: *const ::libc::c_char,
            parent: fuse_ino_t,
            name: *const ::libc::c_char,
        ),
    >,
    #[doc = " Rename a file"]
    #[doc = ""]
    #[doc = " If the target exists it should be atomically replaced. If"]
    #[doc = " the target's inode's lookup count is non-zero, the file"]
    #[doc = " system is expected to postpone any removal of the inode"]
    #[doc = " until the lookup count reaches zero (see description of the"]
    #[doc = " forget function)."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EINVAL, i.e. all"]
    #[doc = " future bmap requests will fail with EINVAL without being"]
    #[doc = " send to the filesystem process."]
    #[doc = ""]
    #[doc = " *flags* may be `RENAME_EXCHANGE` or `RENAME_NOREPLACE`. If"]
    #[doc = " RENAME_NOREPLACE is specified, the filesystem must not"]
    #[doc = " overwrite *newname* if it exists and return an error"]
    #[doc = " instead. If `RENAME_EXCHANGE` is specified, the filesystem"]
    #[doc = " must atomically exchange the two files, i.e. both must"]
    #[doc = " exist and neither may be deleted."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the old parent directory"]
    #[doc = " @param name old name"]
    #[doc = " @param newparent inode number of the new parent directory"]
    #[doc = " @param newname new name"]
    pub rename: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            parent: fuse_ino_t,
            name: *const ::libc::c_char,
            newparent: fuse_ino_t,
            newname: *const ::libc::c_char,
            flags: ::libc::c_uint,
        ),
    >,
    #[doc = " Create a hard link"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_entry"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the old inode number"]
    #[doc = " @param newparent inode number of the new parent directory"]
    #[doc = " @param newname new name to create"]
    pub link: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            newparent: fuse_ino_t,
            newname: *const ::libc::c_char,
        ),
    >,
    #[doc = " Open a file"]
    #[doc = ""]
    #[doc = " Open flags are available in fi->flags. The following rules"]
    #[doc = " apply."]
    #[doc = ""]
    #[doc = "  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be"]
    #[doc = "    filtered out / handled by the kernel."]
    #[doc = ""]
    #[doc = "  - Access modes (O_RDONLY, O_WRONLY, O_RDWR) should be used"]
    #[doc = "    by the filesystem to check if the operation is"]
    #[doc = "    permitted.  If the ``-o default_permissions`` mount"]
    #[doc = "    option is given, this check is already done by the"]
    #[doc = "    kernel before calling open() and may thus be omitted by"]
    #[doc = "    the filesystem."]
    #[doc = ""]
    #[doc = "  - When writeback caching is enabled, the kernel may send"]
    #[doc = "    read requests even for files opened with O_WRONLY. The"]
    #[doc = "    filesystem should be prepared to handle this."]
    #[doc = ""]
    #[doc = "  - When writeback caching is disabled, the filesystem is"]
    #[doc = "    expected to properly handle the O_APPEND flag and ensure"]
    #[doc = "    that each write is appending to the end of the file."]
    #[doc = ""]
    #[doc = "  - When writeback caching is enabled, the kernel will"]
    #[doc = "    handle O_APPEND. However, unless all changes to the file"]
    #[doc = "    come through the kernel this will not work reliably. The"]
    #[doc = "    filesystem should thus either ignore the O_APPEND flag"]
    #[doc = "    (and let the kernel handle it), or return an error"]
    #[doc = "    (indicating that reliably O_APPEND is not available)."]
    #[doc = ""]
    #[doc = " Filesystem may store an arbitrary file handle (pointer,"]
    #[doc = " index, etc) in fi->fh, and use this in other all other file"]
    #[doc = " operations (read, write, flush, release, fsync)."]
    #[doc = ""]
    #[doc = " Filesystem may also implement stateless file I/O and not store"]
    #[doc = " anything in fi->fh."]
    #[doc = ""]
    #[doc = " There are also some flags (direct_io, keep_cache) which the"]
    #[doc = " filesystem may set in fi, to change the way the file is opened."]
    #[doc = " See fuse_file_info structure in <fuse_common.h> for more details."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS"]
    #[doc = " and FUSE_CAP_NO_OPEN_SUPPORT is set in"]
    #[doc = " `fuse_conn_info.capable`, this is treated as success and"]
    #[doc = " future calls to open and release will also succeed without being"]
    #[doc = " sent to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_open"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    pub open: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, fi: *mut fuse_file_info),
    >,
    #[doc = " Read data"]
    #[doc = ""]
    #[doc = " Read should send exactly the number of bytes requested except"]
    #[doc = " on EOF or error, otherwise the rest of the data will be"]
    #[doc = " substituted with zeroes.  An exception to this is when the file"]
    #[doc = " has been opened in 'direct_io' mode, in which case the return"]
    #[doc = " value of the read system call will reflect the return value of"]
    #[doc = " this operation."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the open method, or will"]
    #[doc = " be undefined if the open method didn't set any value."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_buf"]
    #[doc = "   fuse_reply_iov"]
    #[doc = "   fuse_reply_data"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param size number of bytes to read"]
    #[doc = " @param off offset to read from"]
    #[doc = " @param fi file information"]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            size: size_t,
            off: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Write data"]
    #[doc = ""]
    #[doc = " Write should return exactly the number of bytes requested"]
    #[doc = " except on error.  An exception to this is when the file has"]
    #[doc = " been opened in 'direct_io' mode, in which case the return value"]
    #[doc = " of the write system call will reflect the return value of this"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the open method, or will"]
    #[doc = " be undefined if the open method didn't set any value."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_write"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param buf data to write"]
    #[doc = " @param size number of bytes to write"]
    #[doc = " @param off offset to write to"]
    #[doc = " @param fi file information"]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            buf: *const ::libc::c_char,
            size: size_t,
            off: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Flush method"]
    #[doc = ""]
    #[doc = " This is called on each close() of the opened file."]
    #[doc = ""]
    #[doc = " Since file descriptors can be duplicated (dup, dup2, fork), for"]
    #[doc = " one open call there may be many flush calls."]
    #[doc = ""]
    #[doc = " Filesystems shouldn't assume that flush will always be called"]
    #[doc = " after some writes, or that if will be called at all."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the open method, or will"]
    #[doc = " be undefined if the open method didn't set any value."]
    #[doc = ""]
    #[doc = " NOTE: the name of the method is misleading, since (unlike"]
    #[doc = " fsync) the filesystem is not forced to flush pending writes."]
    #[doc = " One reason to flush data is if the filesystem wants to return"]
    #[doc = " write errors during close.  However, such use is non-portable"]
    #[doc = " because POSIX does not require [close] to wait for delayed I/O to"]
    #[doc = " complete."]
    #[doc = ""]
    #[doc = " If the filesystem supports file locking operations (setlk,"]
    #[doc = " getlk) it should remove all locks belonging to 'fi->owner'."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS,"]
    #[doc = " this is treated as success and future calls to flush() will"]
    #[doc = " succeed automatically without being send to the filesystem"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    #[doc = ""]
    #[doc = " [close]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html"]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, fi: *mut fuse_file_info),
    >,
    #[doc = " Release an open file"]
    #[doc = ""]
    #[doc = " Release is called when there are no more references to an open"]
    #[doc = " file: all file descriptors are closed and all memory mappings"]
    #[doc = " are unmapped."]
    #[doc = ""]
    #[doc = " For every open call there will be exactly one release call (unless"]
    #[doc = " the filesystem is force-unmounted)."]
    #[doc = ""]
    #[doc = " The filesystem may reply with an error, but error values are"]
    #[doc = " not returned to close() or munmap() which triggered the"]
    #[doc = " release."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the open method, or will"]
    #[doc = " be undefined if the open method didn't set any value."]
    #[doc = " fi->flags will contain the same flags as for open."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, fi: *mut fuse_file_info),
    >,
    #[doc = " Synchronize file contents"]
    #[doc = ""]
    #[doc = " If the datasync parameter is non-zero, then only the user data"]
    #[doc = " should be flushed, not the meta data."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS,"]
    #[doc = " this is treated as success and future calls to fsync() will"]
    #[doc = " succeed automatically without being send to the filesystem"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param datasync flag indicating if only data should be flushed"]
    #[doc = " @param fi file information"]
    pub fsync: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            datasync: ::libc::c_int,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Open a directory"]
    #[doc = ""]
    #[doc = " Filesystem may store an arbitrary file handle (pointer, index,"]
    #[doc = " etc) in fi->fh, and use this in other all other directory"]
    #[doc = " stream operations (readdir, releasedir, fsyncdir)."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS and"]
    #[doc = " FUSE_CAP_NO_OPENDIR_SUPPORT is set in `fuse_conn_info.capable`,"]
    #[doc = " this is treated as success and future calls to opendir and"]
    #[doc = " releasedir will also succeed without being sent to the filesystem"]
    #[doc = " process. In addition, the kernel will cache readdir results"]
    #[doc = " as if opendir returned FOPEN_KEEP_CACHE | FOPEN_CACHE_DIR."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_open"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    pub opendir: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, fi: *mut fuse_file_info),
    >,
    #[doc = " Read directory"]
    #[doc = ""]
    #[doc = " Send a buffer filled using fuse_add_direntry(), with size not"]
    #[doc = " exceeding the requested size.  Send an empty buffer on end of"]
    #[doc = " stream."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the opendir method, or"]
    #[doc = " will be undefined if the opendir method didn't set any value."]
    #[doc = ""]
    #[doc = " Returning a directory entry from readdir() does not affect"]
    #[doc = " its lookup count."]
    #[doc = ""]
    #[doc = " If off_t is non-zero, then it will correspond to one of the off_t"]
    #[doc = " values that was previously returned by readdir() for the same"]
    #[doc = " directory handle. In this case, readdir() should skip over entries"]
    #[doc = " coming before the position defined by the off_t value. If entries"]
    #[doc = " are added or removed while the directory handle is open, the filesystem"]
    #[doc = " may still include the entries that have been removed, and may not"]
    #[doc = " report the entries that have been created. However, addition or"]
    #[doc = " removal of entries must never cause readdir() to skip over unrelated"]
    #[doc = " entries or to report them more than once. This means"]
    #[doc = " that off_t can not be a simple index that enumerates the entries"]
    #[doc = " that have been returned but must contain sufficient information to"]
    #[doc = " uniquely determine the next directory entry to return even when the"]
    #[doc = " set of entries is changing."]
    #[doc = ""]
    #[doc = " The function does not have to report the '.' and '..'"]
    #[doc = " entries, but is allowed to do so. Note that, if readdir does"]
    #[doc = " not return '.' or '..', they will not be implicitly returned,"]
    #[doc = " and this behavior is observable by the caller."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_buf"]
    #[doc = "   fuse_reply_data"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param size maximum number of bytes to send"]
    #[doc = " @param off offset to continue reading the directory stream"]
    #[doc = " @param fi file information"]
    pub readdir: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            size: size_t,
            off: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Release an open directory"]
    #[doc = ""]
    #[doc = " For every opendir call there will be exactly one releasedir"]
    #[doc = " call (unless the filesystem is force-unmounted)."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the opendir method, or"]
    #[doc = " will be undefined if the opendir method didn't set any value."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    pub releasedir: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, fi: *mut fuse_file_info),
    >,
    #[doc = " Synchronize directory contents"]
    #[doc = ""]
    #[doc = " If the datasync parameter is non-zero, then only the directory"]
    #[doc = " contents should be flushed, not the meta data."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the opendir method, or"]
    #[doc = " will be undefined if the opendir method didn't set any value."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS,"]
    #[doc = " this is treated as success and future calls to fsyncdir() will"]
    #[doc = " succeed automatically without being send to the filesystem"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param datasync flag indicating if only data should be flushed"]
    #[doc = " @param fi file information"]
    pub fsyncdir: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            datasync: ::libc::c_int,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Get file system statistics"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_statfs"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number, zero means \"undefined\""]
    pub statfs: ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t)>,
    #[doc = " Set an extended attribute"]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EOPNOTSUPP, i.e. all"]
    #[doc = " future setxattr() requests will fail with EOPNOTSUPP without being"]
    #[doc = " send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    pub setxattr: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            name: *const ::libc::c_char,
            value: *const ::libc::c_char,
            size: size_t,
            flags: ::libc::c_int,
        ),
    >,
    #[doc = " Get an extended attribute"]
    #[doc = ""]
    #[doc = " If size is zero, the size of the value should be sent with"]
    #[doc = " fuse_reply_xattr."]
    #[doc = ""]
    #[doc = " If the size is non-zero, and the value fits in the buffer, the"]
    #[doc = " value should be sent with fuse_reply_buf."]
    #[doc = ""]
    #[doc = " If the size is too small for the value, the ERANGE error should"]
    #[doc = " be sent."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EOPNOTSUPP, i.e. all"]
    #[doc = " future getxattr() requests will fail with EOPNOTSUPP without being"]
    #[doc = " send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_buf"]
    #[doc = "   fuse_reply_data"]
    #[doc = "   fuse_reply_xattr"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param name of the extended attribute"]
    #[doc = " @param size maximum size of the value to send"]
    pub getxattr: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            name: *const ::libc::c_char,
            size: size_t,
        ),
    >,
    #[doc = " List extended attribute names"]
    #[doc = ""]
    #[doc = " If size is zero, the total size of the attribute list should be"]
    #[doc = " sent with fuse_reply_xattr."]
    #[doc = ""]
    #[doc = " If the size is non-zero, and the null character separated"]
    #[doc = " attribute list fits in the buffer, the list should be sent with"]
    #[doc = " fuse_reply_buf."]
    #[doc = ""]
    #[doc = " If the size is too small for the list, the ERANGE error should"]
    #[doc = " be sent."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EOPNOTSUPP, i.e. all"]
    #[doc = " future listxattr() requests will fail with EOPNOTSUPP without being"]
    #[doc = " send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_buf"]
    #[doc = "   fuse_reply_data"]
    #[doc = "   fuse_reply_xattr"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param size maximum size of the list to send"]
    pub listxattr:
        ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, size: size_t)>,
    #[doc = " Remove an extended attribute"]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EOPNOTSUPP, i.e. all"]
    #[doc = " future removexattr() requests will fail with EOPNOTSUPP without being"]
    #[doc = " send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param name of the extended attribute"]
    pub removexattr: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, name: *const ::libc::c_char),
    >,
    #[doc = " Check file access permissions"]
    #[doc = ""]
    #[doc = " This will be called for the access() and chdir() system"]
    #[doc = " calls.  If the 'default_permissions' mount option is given,"]
    #[doc = " this method is not called."]
    #[doc = ""]
    #[doc = " This method is not called under Linux kernel versions 2.4.x"]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent success, i.e. this and all future access()"]
    #[doc = " requests will succeed without being send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param mask requested access mode"]
    pub access: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, mask: ::libc::c_int),
    >,
    #[doc = " Create and open a file"]
    #[doc = ""]
    #[doc = " If the file does not exist, first create it with the specified"]
    #[doc = " mode, and then open it."]
    #[doc = ""]
    #[doc = " See the description of the open handler for more"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " If this method is not implemented or under Linux kernel"]
    #[doc = " versions earlier than 2.6.15, the mknod() and open() methods"]
    #[doc = " will be called instead."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, the handler"]
    #[doc = " is treated as not implemented (i.e., for this and future requests the"]
    #[doc = " mknod() and open() handlers will be called instead)."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_create"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param parent inode number of the parent directory"]
    #[doc = " @param name to create"]
    #[doc = " @param mode file type and mode with which to create the new file"]
    #[doc = " @param fi file information"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            parent: fuse_ino_t,
            name: *const ::libc::c_char,
            mode: mode_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Test for a POSIX file lock"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_lock"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    #[doc = " @param lock the region/type to test"]
    pub getlk: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            fi: *mut fuse_file_info,
            lock: *mut flock,
        ),
    >,
    #[doc = " Acquire, modify or release a POSIX file lock"]
    #[doc = ""]
    #[doc = " For POSIX threads (NPTL) there's a 1-1 relation between pid and"]
    #[doc = " owner, but otherwise this is not always the case.  For checking"]
    #[doc = " lock ownership, 'fi->owner' must be used.  The l_pid field in"]
    #[doc = " 'struct flock' should only be used to fill in this field in"]
    #[doc = " getlk()."]
    #[doc = ""]
    #[doc = " Note: if the locking methods are not implemented, the kernel"]
    #[doc = " will still allow file locking to work locally.  Hence these are"]
    #[doc = " only interesting for network filesystems and similar."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    #[doc = " @param lock the region/type to set"]
    #[doc = " @param sleep locking operation may sleep"]
    pub setlk: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            fi: *mut fuse_file_info,
            lock: *mut flock,
            sleep: ::libc::c_int,
        ),
    >,
    #[doc = " Map block index within file to block index within device"]
    #[doc = ""]
    #[doc = " Note: This makes sense only for block device backed filesystems"]
    #[doc = " mounted with the 'blkdev' option"]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure, i.e. all future bmap() requests will"]
    #[doc = " fail with the same error code without being send to the filesystem"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_bmap"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param blocksize unit of block index"]
    #[doc = " @param idx block index within file"]
    pub bmap: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, ino: fuse_ino_t, blocksize: size_t, idx: u64),
    >,
    #[doc = " Ioctl"]
    #[doc = ""]
    #[doc = " Note: For unrestricted ioctls (not allowed for FUSE"]
    #[doc = " servers), data in and out areas can be discovered by giving"]
    #[doc = " iovs and setting FUSE_IOCTL_RETRY in *flags*.  For"]
    #[doc = " restricted ioctls, kernel prepares in/out data area"]
    #[doc = " according to the information encoded in cmd."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_ioctl_retry"]
    #[doc = "   fuse_reply_ioctl"]
    #[doc = "   fuse_reply_ioctl_iov"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param cmd ioctl command"]
    #[doc = " @param arg ioctl argument"]
    #[doc = " @param fi file information"]
    #[doc = " @param flags for FUSE_IOCTL_* flags"]
    #[doc = " @param in_buf data fetched from the caller"]
    #[doc = " @param in_bufsz number of fetched bytes"]
    #[doc = " @param out_bufsz maximum size of output data"]
    #[doc = ""]
    #[doc = " Note : the unsigned long request submitted by the application"]
    #[doc = " is truncated to 32 bits."]
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            cmd: ::libc::c_uint,
            arg: *mut ::libc::c_void,
            fi: *mut fuse_file_info,
            flags: ::libc::c_uint,
            in_buf: *const ::libc::c_void,
            in_bufsz: size_t,
            out_bufsz: size_t,
        ),
    >,
    #[doc = " Poll for IO readiness"]
    #[doc = ""]
    #[doc = " Note: If ph is non-NULL, the client should notify"]
    #[doc = " when IO readiness events occur by calling"]
    #[doc = " fuse_lowlevel_notify_poll() with the specified ph."]
    #[doc = ""]
    #[doc = " Regardless of the number of times poll with a non-NULL ph"]
    #[doc = " is received, single notification is enough to clear all."]
    #[doc = " Notifying more times incurs overhead but doesn't harm"]
    #[doc = " correctness."]
    #[doc = ""]
    #[doc = " The callee is responsible for destroying ph with"]
    #[doc = " fuse_pollhandle_destroy() when no longer in use."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as success (with a kernel-defined default poll-mask) and"]
    #[doc = " future calls to pull() will succeed the same way without being send"]
    #[doc = " to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_poll"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    #[doc = " @param ph poll handle to be used for notification"]
    pub poll: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            fi: *mut fuse_file_info,
            ph: *mut fuse_pollhandle,
        ),
    >,
    #[doc = " Write data made available in a buffer"]
    #[doc = ""]
    #[doc = " This is a more generic version of the ->write() method.  If"]
    #[doc = " FUSE_CAP_SPLICE_READ is set in fuse_conn_info.want and the"]
    #[doc = " kernel supports splicing from the fuse device, then the"]
    #[doc = " data will be made available in pipe for supporting zero"]
    #[doc = " copy data transfer."]
    #[doc = ""]
    #[doc = " buf->count is guaranteed to be one (and thus buf->idx is"]
    #[doc = " always zero). The write_buf handler must ensure that"]
    #[doc = " bufv->off is correctly updated (reflecting the number of"]
    #[doc = " bytes read from bufv->buf[0])."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_write"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param bufv buffer containing the data"]
    #[doc = " @param off offset to write to"]
    #[doc = " @param fi file information"]
    pub write_buf: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            bufv: *mut fuse_bufvec,
            off: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Callback function for the retrieve request"]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "\tfuse_reply_none"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param cookie user data supplied to fuse_lowlevel_notify_retrieve()"]
    #[doc = " @param ino the inode number supplied to fuse_lowlevel_notify_retrieve()"]
    #[doc = " @param offset the offset supplied to fuse_lowlevel_notify_retrieve()"]
    #[doc = " @param bufv the buffer containing the returned data"]
    pub retrieve_reply: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            cookie: *mut ::libc::c_void,
            ino: fuse_ino_t,
            offset: off_t,
            bufv: *mut fuse_bufvec,
        ),
    >,
    #[doc = " Forget about multiple inodes"]
    #[doc = ""]
    #[doc = " See description of the forget function for more"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_none"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    pub forget_multi: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, count: size_t, forgets: *mut fuse_forget_data),
    >,
    #[doc = " Acquire, modify or release a BSD file lock"]
    #[doc = ""]
    #[doc = " Note: if the locking methods are not implemented, the kernel"]
    #[doc = " will still allow file locking to work locally.  Hence these are"]
    #[doc = " only interesting for network filesystems and similar."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param fi file information"]
    #[doc = " @param op the locking operation, see flock(2)"]
    pub flock: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            fi: *mut fuse_file_info,
            op: ::libc::c_int,
        ),
    >,
    #[doc = " Allocate requested space. If this function returns success then"]
    #[doc = " subsequent writes to the specified range shall not fail due to the lack"]
    #[doc = " of free space on the file system storage media."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EOPNOTSUPP, i.e. all"]
    #[doc = " future fallocate() requests will fail with EOPNOTSUPP without being"]
    #[doc = " send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param offset starting point for allocated region"]
    #[doc = " @param length size of allocated region"]
    #[doc = " @param mode determines the operation to be performed on the given range,"]
    #[doc = "             see fallocate(2)"]
    pub fallocate: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            mode: ::libc::c_int,
            offset: off_t,
            length: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Read directory with attributes"]
    #[doc = ""]
    #[doc = " Send a buffer filled using fuse_add_direntry_plus(), with size not"]
    #[doc = " exceeding the requested size.  Send an empty buffer on end of"]
    #[doc = " stream."]
    #[doc = ""]
    #[doc = " fi->fh will contain the value set by the opendir method, or"]
    #[doc = " will be undefined if the opendir method didn't set any value."]
    #[doc = ""]
    #[doc = " In contrast to readdir() (which does not affect the lookup counts),"]
    #[doc = " the lookup count of every entry returned by readdirplus(), except \".\""]
    #[doc = " and \"..\", is incremented by one."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_buf"]
    #[doc = "   fuse_reply_data"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param size maximum number of bytes to send"]
    #[doc = " @param off offset to continue reading the directory stream"]
    #[doc = " @param fi file information"]
    pub readdirplus: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            size: size_t,
            off: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    #[doc = " Copy a range of data from one file to another"]
    #[doc = ""]
    #[doc = " Performs an optimized copy between two file descriptors without the"]
    #[doc = " additional cost of transferring data through the FUSE kernel module"]
    #[doc = " to user space (glibc) and then back into the FUSE filesystem again."]
    #[doc = ""]
    #[doc = " In case this method is not implemented, glibc falls back to reading"]
    #[doc = " data from the source and writing to the destination. Effectively"]
    #[doc = " doing an inefficient copy of the data."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure with error code EOPNOTSUPP, i.e. all"]
    #[doc = " future copy_file_range() requests will fail with EOPNOTSUPP without"]
    #[doc = " being send to the filesystem process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_write"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino_in the inode number or the source file"]
    #[doc = " @param off_in starting point from were the data should be read"]
    #[doc = " @param fi_in file information of the source file"]
    #[doc = " @param ino_out the inode number or the destination file"]
    #[doc = " @param off_out starting point where the data should be written"]
    #[doc = " @param fi_out file information of the destination file"]
    #[doc = " @param len maximum size of the data to copy"]
    #[doc = " @param flags passed along with the copy_file_range() syscall"]
    pub copy_file_range: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino_in: fuse_ino_t,
            off_in: off_t,
            fi_in: *mut fuse_file_info,
            ino_out: fuse_ino_t,
            off_out: off_t,
            fi_out: *mut fuse_file_info,
            len: size_t,
            flags: ::libc::c_int,
        ),
    >,
    #[doc = " Find next data or hole after the specified offset"]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS, this is"]
    #[doc = " treated as a permanent failure, i.e. all future lseek() requests will"]
    #[doc = " fail with the same error code without being send to the filesystem"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " Valid replies:"]
    #[doc = "   fuse_reply_lseek"]
    #[doc = "   fuse_reply_err"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param off offset to start search from"]
    #[doc = " @param whence either SEEK_DATA or SEEK_HOLE"]
    #[doc = " @param fi file information"]
    pub lseek: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            ino: fuse_ino_t,
            off: off_t,
            whence: ::libc::c_int,
            fi: *mut fuse_file_info,
        ),
    >,
}
#[test]
fn bindgen_test_layout_fuse_lowlevel_ops() {
    assert_eq!(
        ::std::mem::size_of::<fuse_lowlevel_ops>(),
        352usize,
        concat!("Size of: ", stringify!(fuse_lowlevel_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_lowlevel_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_lowlevel_ops))
    );
    fn test_field_init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(init)
            )
        );
    }
    test_field_init();
    fn test_field_destroy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(destroy)
            )
        );
    }
    test_field_destroy();
    fn test_field_lookup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(lookup)
            )
        );
    }
    test_field_lookup();
    fn test_field_forget() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forget) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(forget)
            )
        );
    }
    test_field_forget();
    fn test_field_getattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getattr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(getattr)
            )
        );
    }
    test_field_getattr();
    fn test_field_setattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setattr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(setattr)
            )
        );
    }
    test_field_setattr();
    fn test_field_readlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readlink) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(readlink)
            )
        );
    }
    test_field_readlink();
    fn test_field_mknod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mknod) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(mknod)
            )
        );
    }
    test_field_mknod();
    fn test_field_mkdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(mkdir)
            )
        );
    }
    test_field_mkdir();
    fn test_field_unlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unlink) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(unlink)
            )
        );
    }
    test_field_unlink();
    fn test_field_rmdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rmdir) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(rmdir)
            )
        );
    }
    test_field_rmdir();
    fn test_field_symlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symlink) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(symlink)
            )
        );
    }
    test_field_symlink();
    fn test_field_rename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rename) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(rename)
            )
        );
    }
    test_field_rename();
    fn test_field_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(link)
            )
        );
    }
    test_field_link();
    fn test_field_open() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(open)
            )
        );
    }
    test_field_open();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
    fn test_field_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(flush)
            )
        );
    }
    test_field_flush();
    fn test_field_release() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(release)
            )
        );
    }
    test_field_release();
    fn test_field_fsync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsync) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(fsync)
            )
        );
    }
    test_field_fsync();
    fn test_field_opendir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opendir) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(opendir)
            )
        );
    }
    test_field_opendir();
    fn test_field_readdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readdir) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(readdir)
            )
        );
    }
    test_field_readdir();
    fn test_field_releasedir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).releasedir) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(releasedir)
            )
        );
    }
    test_field_releasedir();
    fn test_field_fsyncdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsyncdir) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(fsyncdir)
            )
        );
    }
    test_field_fsyncdir();
    fn test_field_statfs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statfs) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(statfs)
            )
        );
    }
    test_field_statfs();
    fn test_field_setxattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setxattr) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(setxattr)
            )
        );
    }
    test_field_setxattr();
    fn test_field_getxattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getxattr) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(getxattr)
            )
        );
    }
    test_field_getxattr();
    fn test_field_listxattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).listxattr) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(listxattr)
            )
        );
    }
    test_field_listxattr();
    fn test_field_removexattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).removexattr) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(removexattr)
            )
        );
    }
    test_field_removexattr();
    fn test_field_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(access)
            )
        );
    }
    test_field_access();
    fn test_field_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(create)
            )
        );
    }
    test_field_create();
    fn test_field_getlk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getlk) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(getlk)
            )
        );
    }
    test_field_getlk();
    fn test_field_setlk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setlk) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(setlk)
            )
        );
    }
    test_field_setlk();
    fn test_field_bmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bmap) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(bmap)
            )
        );
    }
    test_field_bmap();
    fn test_field_ioctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(ioctl)
            )
        );
    }
    test_field_ioctl();
    fn test_field_poll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(poll)
            )
        );
    }
    test_field_poll();
    fn test_field_write_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(write_buf)
            )
        );
    }
    test_field_write_buf();
    fn test_field_retrieve_reply() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).retrieve_reply) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(retrieve_reply)
            )
        );
    }
    test_field_retrieve_reply();
    fn test_field_forget_multi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forget_multi) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(forget_multi)
            )
        );
    }
    test_field_forget_multi();
    fn test_field_flock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flock) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(flock)
            )
        );
    }
    test_field_flock();
    fn test_field_fallocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fallocate) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(fallocate)
            )
        );
    }
    test_field_fallocate();
    fn test_field_readdirplus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readdirplus) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(readdirplus)
            )
        );
    }
    test_field_readdirplus();
    fn test_field_copy_file_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy_file_range) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(copy_file_range)
            )
        );
    }
    test_field_copy_file_range();
    fn test_field_lseek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lseek) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lowlevel_ops),
                "::",
                stringify!(lseek)
            )
        );
    }
    test_field_lseek();
}
extern "C" {
    #[doc = " Reply with an error code or success."]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   all except forget, forget_multi, retrieve_reply"]
    #[doc = ""]
    #[doc = " Wherever possible, error codes should be chosen from the list of"]
    #[doc = " documented error conditions in the corresponding system calls"]
    #[doc = " manpage."]
    #[doc = ""]
    #[doc = " An error code of ENOSYS is sometimes treated specially. This is"]
    #[doc = " indicated in the documentation of the affected handler functions."]
    #[doc = ""]
    #[doc = " The following requests may be answered with a zero error code:"]
    #[doc = " unlink, rmdir, rename, flush, release, fsync, fsyncdir, setxattr,"]
    #[doc = " removexattr, setlk."]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param err the positive error value, or zero for success"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_err(req: fuse_req_t, err: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Don't send reply"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   forget"]
    #[doc = "   forget_multi"]
    #[doc = "   retrieve_reply"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    pub fn fuse_reply_none(req: fuse_req_t);
}
extern "C" {
    #[doc = " Reply with a directory entry"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   lookup, mknod, mkdir, symlink, link"]
    #[doc = ""]
    #[doc = " Side effects:"]
    #[doc = "   increments the lookup count on success"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param e the entry parameters"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_entry(req: fuse_req_t, e: *const fuse_entry_param) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with a directory entry and open parameters"]
    #[doc = ""]
    #[doc = " currently the following members of 'fi' are used:"]
    #[doc = "   fh, direct_io, keep_cache"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   create"]
    #[doc = ""]
    #[doc = " Side effects:"]
    #[doc = "   increments the lookup count on success"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param e the entry parameters"]
    #[doc = " @param fi file information"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_create(
        req: fuse_req_t,
        e: *const fuse_entry_param,
        fi: *const fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with attributes"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   getattr, setattr"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param attr the attributes"]
    #[doc = " @param attr_timeout\tvalidity timeout (in seconds) for the attributes"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_attr(req: fuse_req_t, attr: *const stat, attr_timeout: f64) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with the contents of a symbolic link"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   readlink"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param link symbolic link contents"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_readlink(req: fuse_req_t, link: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with open parameters"]
    #[doc = ""]
    #[doc = " currently the following members of 'fi' are used:"]
    #[doc = "   fh, direct_io, keep_cache"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   open, opendir"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param fi file information"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_open(req: fuse_req_t, fi: *const fuse_file_info) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with number of bytes written"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   write"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param count the number of bytes written"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_write(req: fuse_req_t, count: size_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with data"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   read, readdir, getxattr, listxattr"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param buf buffer containing data"]
    #[doc = " @param size the size of data in bytes"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_buf(
        req: fuse_req_t,
        buf: *const ::libc::c_char,
        size: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with data copied/moved from buffer(s)"]
    #[doc = ""]
    #[doc = " Zero copy data transfer (\"splicing\") will be used under"]
    #[doc = " the following circumstances:"]
    #[doc = ""]
    #[doc = " 1. FUSE_CAP_SPLICE_WRITE is set in fuse_conn_info.want, and"]
    #[doc = " 2. the kernel supports splicing from the fuse device"]
    #[doc = "    (FUSE_CAP_SPLICE_WRITE is set in fuse_conn_info.capable), and"]
    #[doc = " 3. *flags* does not contain FUSE_BUF_NO_SPLICE"]
    #[doc = " 4. The amount of data that is provided in file-descriptor backed"]
    #[doc = "    buffers (i.e., buffers for which bufv[n].flags == FUSE_BUF_FD)"]
    #[doc = "    is at least twice the page size."]
    #[doc = ""]
    #[doc = " In order for SPLICE_F_MOVE to be used, the following additional"]
    #[doc = " conditions have to be fulfilled:"]
    #[doc = ""]
    #[doc = " 1. FUSE_CAP_SPLICE_MOVE is set in fuse_conn_info.want, and"]
    #[doc = " 2. the kernel supports it (i.e, FUSE_CAP_SPLICE_MOVE is set in"]
    #[doc = "fuse_conn_info.capable), and"]
    #[doc = " 3. *flags* contains FUSE_BUF_SPLICE_MOVE"]
    #[doc = ""]
    #[doc = " Note that, if splice is used, the data is actually spliced twice:"]
    #[doc = " once into a temporary pipe (to prepend header data), and then again"]
    #[doc = " into the kernel. If some of the provided buffers are memory-backed,"]
    #[doc = " the data in them is copied in step one and spliced in step two."]
    #[doc = ""]
    #[doc = " The FUSE_BUF_SPLICE_FORCE_SPLICE and FUSE_BUF_SPLICE_NONBLOCK flags"]
    #[doc = " are silently ignored."]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   read, readdir, getxattr, listxattr"]
    #[doc = ""]
    #[doc = " Side effects:"]
    #[doc = "   when used to return data from a readdirplus() (but not readdir())"]
    #[doc = "   call, increments the lookup count of each returned entry by one"]
    #[doc = "   on success."]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param bufv buffer vector"]
    #[doc = " @param flags flags controlling the copy"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_data(
        req: fuse_req_t,
        bufv: *mut fuse_bufvec,
        flags: fuse_buf_copy_flags,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with data vector"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   read, readdir, getxattr, listxattr"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param iov the vector containing the data"]
    #[doc = " @param count the size of vector"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_iov(
        req: fuse_req_t,
        iov: *const iovec,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with filesystem statistics"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   statfs"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param stbuf filesystem statistics"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_statfs(req: fuse_req_t, stbuf: *const statvfs) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with needed buffer size"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   getxattr, listxattr"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param count the buffer size needed in bytes"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_xattr(req: fuse_req_t, count: size_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with file lock information"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   getlk"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param lock the lock information"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_lock(req: fuse_req_t, lock: *const flock) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with block index"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   bmap"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param idx block index within device"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_bmap(req: fuse_req_t, idx: u64) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Add a directory entry to the buffer"]
    #[doc = ""]
    #[doc = " Buffer needs to be large enough to hold the entry.  If it's not,"]
    #[doc = " then the entry is not filled in but the size of the entry is still"]
    #[doc = " returned.  The caller can check this by comparing the bufsize"]
    #[doc = " parameter with the returned entry size.  If the entry size is"]
    #[doc = " larger than the buffer size, the operation failed."]
    #[doc = ""]
    #[doc = " From the 'stbuf' argument the st_ino field and bits 12-15 of the"]
    #[doc = " st_mode field are used.  The other fields are ignored."]
    #[doc = ""]
    #[doc = " *off* should be any non-zero value that the filesystem can use to"]
    #[doc = " identify the current point in the directory stream. It does not"]
    #[doc = " need to be the actual physical position. A value of zero is"]
    #[doc = " reserved to mean \"from the beginning\", and should therefore never"]
    #[doc = " be used (the first call to fuse_add_direntry should be passed the"]
    #[doc = " offset of the second directory entry)."]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param buf the point where the new entry will be added to the buffer"]
    #[doc = " @param bufsize remaining size of the buffer"]
    #[doc = " @param name the name of the entry"]
    #[doc = " @param stbuf the file attributes"]
    #[doc = " @param off the offset of the next entry"]
    #[doc = " @return the space needed for the entry"]
    pub fn fuse_add_direntry(
        req: fuse_req_t,
        buf: *mut ::libc::c_char,
        bufsize: size_t,
        name: *const ::libc::c_char,
        stbuf: *const stat,
        off: off_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Add a directory entry to the buffer with the attributes"]
    #[doc = ""]
    #[doc = " See documentation of `fuse_add_direntry()` for more details."]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param buf the point where the new entry will be added to the buffer"]
    #[doc = " @param bufsize remaining size of the buffer"]
    #[doc = " @param name the name of the entry"]
    #[doc = " @param e the directory entry"]
    #[doc = " @param off the offset of the next entry"]
    #[doc = " @return the space needed for the entry"]
    pub fn fuse_add_direntry_plus(
        req: fuse_req_t,
        buf: *mut ::libc::c_char,
        bufsize: size_t,
        name: *const ::libc::c_char,
        e: *const fuse_entry_param,
        off: off_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Reply to ask for data fetch and output buffer preparation.  ioctl"]
    #[doc = " will be retried with the specified input data fetched and output"]
    #[doc = " buffer prepared."]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   ioctl"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param in_iov iovec specifying data to fetch from the caller"]
    #[doc = " @param in_count number of entries in in_iov"]
    #[doc = " @param out_iov iovec specifying addresses to write output to"]
    #[doc = " @param out_count number of entries in out_iov"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_ioctl_retry(
        req: fuse_req_t,
        in_iov: *const iovec,
        in_count: size_t,
        out_iov: *const iovec,
        out_count: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply to finish ioctl"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   ioctl"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param result result to be passed to the caller"]
    #[doc = " @param buf buffer containing output data"]
    #[doc = " @param size length of output data"]
    pub fn fuse_reply_ioctl(
        req: fuse_req_t,
        result: ::libc::c_int,
        buf: *const ::libc::c_void,
        size: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply to finish ioctl with iov buffer"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   ioctl"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param result result to be passed to the caller"]
    #[doc = " @param iov the vector containing the data"]
    #[doc = " @param count the size of vector"]
    pub fn fuse_reply_ioctl_iov(
        req: fuse_req_t,
        result: ::libc::c_int,
        iov: *const iovec,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with poll result event mask"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param revents poll result event mask"]
    pub fn fuse_reply_poll(req: fuse_req_t, revents: ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reply with offset"]
    #[doc = ""]
    #[doc = " Possible requests:"]
    #[doc = "   lseek"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param off offset of next data or hole"]
    #[doc = " @return zero for success, -errno for failure to send reply"]
    pub fn fuse_reply_lseek(req: fuse_req_t, off: off_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Notify IO readiness event"]
    #[doc = ""]
    #[doc = " For more information, please read comment for poll operation."]
    #[doc = ""]
    #[doc = " @param ph poll handle to notify IO readiness event for"]
    pub fn fuse_lowlevel_notify_poll(ph: *mut fuse_pollhandle) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Notify to invalidate cache for an inode."]
    #[doc = ""]
    #[doc = " Added in FUSE protocol version 7.12. If the kernel does not support"]
    #[doc = " this (or a newer) version, the function will return -ENOSYS and do"]
    #[doc = " nothing."]
    #[doc = ""]
    #[doc = " If the filesystem has writeback caching enabled, invalidating an"]
    #[doc = " inode will first trigger a writeback of all dirty pages. The call"]
    #[doc = " will block until all writeback requests have completed and the"]
    #[doc = " inode has been invalidated. It will, however, not wait for"]
    #[doc = " completion of pending writeback requests that have been issued"]
    #[doc = " before."]
    #[doc = ""]
    #[doc = " If there are no dirty pages, this function will never block."]
    #[doc = ""]
    #[doc = " @param se the session object"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param off the offset in the inode where to start invalidating"]
    #[doc = "            or negative to invalidate attributes only"]
    #[doc = " @param len the amount of cache to invalidate or 0 for all"]
    #[doc = " @return zero for success, -errno for failure"]
    pub fn fuse_lowlevel_notify_inval_inode(
        se: *mut fuse_session,
        ino: fuse_ino_t,
        off: off_t,
        len: off_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Notify to invalidate parent attributes and the dentry matching"]
    #[doc = " parent/name"]
    #[doc = ""]
    #[doc = " To avoid a deadlock this function must not be called in the"]
    #[doc = " execution path of a related filesytem operation or within any code"]
    #[doc = " that could hold a lock that could be needed to execute such an"]
    #[doc = " operation. As of kernel 4.18, a \"related operation\" is a lookup(),"]
    #[doc = " symlink(), mknod(), mkdir(), unlink(), rename(), link() or create()"]
    #[doc = " request for the parent, and a setattr(), unlink(), rmdir(),"]
    #[doc = " rename(), setxattr(), removexattr(), readdir() or readdirplus()"]
    #[doc = " request for the inode itself."]
    #[doc = ""]
    #[doc = " When called correctly, this function will never block."]
    #[doc = ""]
    #[doc = " Added in FUSE protocol version 7.12. If the kernel does not support"]
    #[doc = " this (or a newer) version, the function will return -ENOSYS and do"]
    #[doc = " nothing."]
    #[doc = ""]
    #[doc = " @param se the session object"]
    #[doc = " @param parent inode number"]
    #[doc = " @param name file name"]
    #[doc = " @param namelen strlen() of file name"]
    #[doc = " @return zero for success, -errno for failure"]
    pub fn fuse_lowlevel_notify_inval_entry(
        se: *mut fuse_session,
        parent: fuse_ino_t,
        name: *const ::libc::c_char,
        namelen: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " This function behaves like fuse_lowlevel_notify_inval_entry() with"]
    #[doc = " the following additional effect (at least as of Linux kernel 4.8):"]
    #[doc = ""]
    #[doc = " If the provided *child* inode matches the inode that is currently"]
    #[doc = " associated with the cached dentry, and if there are any inotify"]
    #[doc = " watches registered for the dentry, then the watchers are informed"]
    #[doc = " that the dentry has been deleted."]
    #[doc = ""]
    #[doc = " To avoid a deadlock this function must not be called while"]
    #[doc = " executing a related filesytem operation or while holding a lock"]
    #[doc = " that could be needed to execute such an operation (see the"]
    #[doc = " description of fuse_lowlevel_notify_inval_entry() for more"]
    #[doc = " details)."]
    #[doc = ""]
    #[doc = " When called correctly, this function will never block."]
    #[doc = ""]
    #[doc = " Added in FUSE protocol version 7.18. If the kernel does not support"]
    #[doc = " this (or a newer) version, the function will return -ENOSYS and do"]
    #[doc = " nothing."]
    #[doc = ""]
    #[doc = " @param se the session object"]
    #[doc = " @param parent inode number"]
    #[doc = " @param child inode number"]
    #[doc = " @param name file name"]
    #[doc = " @param namelen strlen() of file name"]
    #[doc = " @return zero for success, -errno for failure"]
    pub fn fuse_lowlevel_notify_delete(
        se: *mut fuse_session,
        parent: fuse_ino_t,
        child: fuse_ino_t,
        name: *const ::libc::c_char,
        namelen: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Store data to the kernel buffers"]
    #[doc = ""]
    #[doc = " Synchronously store data in the kernel buffers belonging to the"]
    #[doc = " given inode.  The stored data is marked up-to-date (no read will be"]
    #[doc = " performed against it, unless it's invalidated or evicted from the"]
    #[doc = " cache)."]
    #[doc = ""]
    #[doc = " If the stored data overflows the current file size, then the size"]
    #[doc = " is extended, similarly to a write(2) on the filesystem."]
    #[doc = ""]
    #[doc = " If this function returns an error, then the store wasn't fully"]
    #[doc = " completed, but it may have been partially completed."]
    #[doc = ""]
    #[doc = " Added in FUSE protocol version 7.15. If the kernel does not support"]
    #[doc = " this (or a newer) version, the function will return -ENOSYS and do"]
    #[doc = " nothing."]
    #[doc = ""]
    #[doc = " @param se the session object"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param offset the starting offset into the file to store to"]
    #[doc = " @param bufv buffer vector"]
    #[doc = " @param flags flags controlling the copy"]
    #[doc = " @return zero for success, -errno for failure"]
    pub fn fuse_lowlevel_notify_store(
        se: *mut fuse_session,
        ino: fuse_ino_t,
        offset: off_t,
        bufv: *mut fuse_bufvec,
        flags: fuse_buf_copy_flags,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Retrieve data from the kernel buffers"]
    #[doc = ""]
    #[doc = " Retrieve data in the kernel buffers belonging to the given inode."]
    #[doc = " If successful then the retrieve_reply() method will be called with"]
    #[doc = " the returned data."]
    #[doc = ""]
    #[doc = " Only present pages are returned in the retrieve reply.  Retrieving"]
    #[doc = " stops when it finds a non-present page and only data prior to that"]
    #[doc = " is returned."]
    #[doc = ""]
    #[doc = " If this function returns an error, then the retrieve will not be"]
    #[doc = " completed and no reply will be sent."]
    #[doc = ""]
    #[doc = " This function doesn't change the dirty state of pages in the kernel"]
    #[doc = " buffer.  For dirty pages the write() method will be called"]
    #[doc = " regardless of having been retrieved previously."]
    #[doc = ""]
    #[doc = " Added in FUSE protocol version 7.15. If the kernel does not support"]
    #[doc = " this (or a newer) version, the function will return -ENOSYS and do"]
    #[doc = " nothing."]
    #[doc = ""]
    #[doc = " @param se the session object"]
    #[doc = " @param ino the inode number"]
    #[doc = " @param size the number of bytes to retrieve"]
    #[doc = " @param offset the starting offset into the file to retrieve from"]
    #[doc = " @param cookie user data to supply to the reply callback"]
    #[doc = " @return zero for success, -errno for failure"]
    pub fn fuse_lowlevel_notify_retrieve(
        se: *mut fuse_session,
        ino: fuse_ino_t,
        size: size_t,
        offset: off_t,
        cookie: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the userdata from the request"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @return the user data passed to fuse_session_new()"]
    pub fn fuse_req_userdata(req: fuse_req_t) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " Get the context from the request"]
    #[doc = ""]
    #[doc = " The pointer returned by this function will only be valid for the"]
    #[doc = " request's lifetime"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @return the context structure"]
    pub fn fuse_req_ctx(req: fuse_req_t) -> *const fuse_ctx;
}
extern "C" {
    #[doc = " Get the current supplementary group IDs for the specified request"]
    #[doc = ""]
    #[doc = " Similar to the getgroups(2) system call, except the return value is"]
    #[doc = " always the total number of group IDs, even if it is larger than the"]
    #[doc = " specified size."]
    #[doc = ""]
    #[doc = " The current fuse kernel module in linux (as of 2.6.30) doesn't pass"]
    #[doc = " the group list to userspace, hence this function needs to parse"]
    #[doc = " \"/proc/$TID/task/$TID/status\" to get the group IDs."]
    #[doc = ""]
    #[doc = " This feature may not be supported on all operating systems.  In"]
    #[doc = " such a case this function will return -ENOSYS."]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param size size of given array"]
    #[doc = " @param list array of group IDs to be filled in"]
    #[doc = " @return the total number of supplementary group IDs or -errno on failure"]
    pub fn fuse_req_getgroups(
        req: fuse_req_t,
        size: ::libc::c_int,
        list: *mut gid_t,
    ) -> ::libc::c_int;
}
#[doc = " Callback function for an interrupt"]
#[doc = ""]
#[doc = " @param req interrupted request"]
#[doc = " @param data user data"]
pub type fuse_interrupt_func_t =
    ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, data: *mut ::libc::c_void)>;
extern "C" {
    #[doc = " Register/unregister callback for an interrupt"]
    #[doc = ""]
    #[doc = " If an interrupt has already happened, then the callback function is"]
    #[doc = " called from within this function, hence it's not possible for"]
    #[doc = " interrupts to be lost."]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @param func the callback function or NULL for unregister"]
    #[doc = " @param data user data passed to the callback function"]
    pub fn fuse_req_interrupt_func(
        req: fuse_req_t,
        func: fuse_interrupt_func_t,
        data: *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = " Check if a request has already been interrupted"]
    #[doc = ""]
    #[doc = " @param req request handle"]
    #[doc = " @return 1 if the request has been interrupted, 0 otherwise"]
    pub fn fuse_req_interrupted(req: fuse_req_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Print low-level version information to stdout."]
    pub fn fuse_lowlevel_version();
}
extern "C" {
    #[doc = " Print available low-level options to stdout. This is not an"]
    #[doc = " exhaustive list, but includes only those options that may be of"]
    #[doc = " interest to an end-user of a file system."]
    pub fn fuse_lowlevel_help();
}
extern "C" {
    #[doc = " Print available options for `fuse_parse_cmdline()`."]
    pub fn fuse_cmdline_help();
}
#[doc = " Note: Any addition to this struct needs to create a compatibility symbol"]
#[doc = "       for fuse_parse_cmdline(). For ABI compatibility reasons it is also"]
#[doc = "       not possible to remove struct members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_cmdline_opts {
    pub singlethread: ::libc::c_int,
    pub foreground: ::libc::c_int,
    pub debug: ::libc::c_int,
    pub nodefault_subtype: ::libc::c_int,
    pub mountpoint: *mut ::libc::c_char,
    pub show_version: ::libc::c_int,
    pub show_help: ::libc::c_int,
    pub clone_fd: ::libc::c_int,
    pub max_idle_threads: ::libc::c_uint,
    pub max_threads: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_fuse_cmdline_opts() {
    assert_eq!(
        ::std::mem::size_of::<fuse_cmdline_opts>(),
        48usize,
        concat!("Size of: ", stringify!(fuse_cmdline_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_cmdline_opts>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_cmdline_opts))
    );
    fn test_field_singlethread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).singlethread) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(singlethread)
            )
        );
    }
    test_field_singlethread();
    fn test_field_foreground() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).foreground) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(foreground)
            )
        );
    }
    test_field_foreground();
    fn test_field_debug() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(debug)
            )
        );
    }
    test_field_debug();
    fn test_field_nodefault_subtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodefault_subtype) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(nodefault_subtype)
            )
        );
    }
    test_field_nodefault_subtype();
    fn test_field_mountpoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mountpoint) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(mountpoint)
            )
        );
    }
    test_field_mountpoint();
    fn test_field_show_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).show_version) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(show_version)
            )
        );
    }
    test_field_show_version();
    fn test_field_show_help() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).show_help) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(show_help)
            )
        );
    }
    test_field_show_help();
    fn test_field_clone_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clone_fd) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(clone_fd)
            )
        );
    }
    test_field_clone_fd();
    fn test_field_max_idle_threads() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_idle_threads) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(max_idle_threads)
            )
        );
    }
    test_field_max_idle_threads();
    fn test_field_max_threads() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_cmdline_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_threads) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_cmdline_opts),
                "::",
                stringify!(max_threads)
            )
        );
    }
    test_field_max_threads();
}
extern "C" {
    pub fn fuse_parse_cmdline(args: *mut fuse_args, opts: *mut fuse_cmdline_opts) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Create a low level session."]
    #[doc = ""]
    #[doc = " Returns a session structure suitable for passing to"]
    #[doc = " fuse_session_mount() and fuse_session_loop()."]
    #[doc = ""]
    #[doc = " This function accepts most file-system independent mount options"]
    #[doc = " (like context, nodev, ro - see mount(8)), as well as the general"]
    #[doc = " fuse mount options listed in mount.fuse(8) (e.g. -o allow_root and"]
    #[doc = " -o default_permissions, but not ``-o use_ino``).  Instead of `-o"]
    #[doc = " debug`, debugging may also enabled with `-d` or `--debug`."]
    #[doc = ""]
    #[doc = " If not all options are known, an error message is written to stderr"]
    #[doc = " and the function returns NULL."]
    #[doc = ""]
    #[doc = " Option parsing skips argv[0], which is assumed to contain the"]
    #[doc = " program name. To prevent accidentally passing an option in"]
    #[doc = " argv[0], this element must always be present (even if no options"]
    #[doc = " are specified). It may be set to the empty string ('\\0') if no"]
    #[doc = " reasonable value can be provided."]
    #[doc = ""]
    #[doc = " @param args argument vector"]
    #[doc = " @param op the (low-level) filesystem operations"]
    #[doc = " @param op_size sizeof(struct fuse_lowlevel_ops)"]
    #[doc = " @param userdata user data"]
    #[doc = ""]
    #[doc = " @return the fuse session on success, NULL on failure"]
    pub fn fuse_session_new(
        args: *mut fuse_args,
        op: *const fuse_lowlevel_ops,
        op_size: size_t,
        userdata: *mut ::libc::c_void,
    ) -> *mut fuse_session;
}
extern "C" {
    #[doc = " Mount a FUSE file system."]
    #[doc = ""]
    #[doc = " @param mountpoint the mount point path"]
    #[doc = " @param se session object"]
    #[doc = ""]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn fuse_session_mount(
        se: *mut fuse_session,
        mountpoint: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Enter a single threaded, blocking event loop."]
    #[doc = ""]
    #[doc = " When the event loop terminates because the connection to the FUSE"]
    #[doc = " kernel module has been closed, this function returns zero. This"]
    #[doc = " happens when the filesystem is unmounted regularly (by the"]
    #[doc = " filesystem owner or root running the umount(8) or fusermount(1)"]
    #[doc = " command), or if connection is explicitly severed by writing ``1``"]
    #[doc = " to the``abort`` file in ``/sys/fs/fuse/connections/NNN``. The only"]
    #[doc = " way to distinguish between these two conditions is to check if the"]
    #[doc = " filesystem is still mounted after the session loop returns."]
    #[doc = ""]
    #[doc = " When some error occurs during request processing, the function"]
    #[doc = " returns a negated errno(3) value."]
    #[doc = ""]
    #[doc = " If the loop has been terminated because of a signal handler"]
    #[doc = " installed by fuse_set_signal_handlers(), this function returns the"]
    #[doc = " (positive) signal value that triggered the exit."]
    #[doc = ""]
    #[doc = " @param se the session"]
    #[doc = " @return 0, -errno, or a signal value"]
    pub fn fuse_session_loop(se: *mut fuse_session) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Enter a multi-threaded event loop."]
    #[doc = ""]
    #[doc = " For a description of the return value and the conditions when the"]
    #[doc = " event loop exits, refer to the documentation of"]
    #[doc = " fuse_session_loop()."]
    #[doc = ""]
    #[doc = " @param se the session"]
    #[doc = " @param config session loop configuration"]
    #[doc = " @return see fuse_session_loop()"]
    pub fn fuse_session_loop_mt(
        se: *mut fuse_session,
        config: *mut fuse_loop_config,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Flag a session as terminated."]
    #[doc = ""]
    #[doc = " This function is invoked by the POSIX signal handlers, when"]
    #[doc = " registered using fuse_set_signal_handlers(). It will cause any"]
    #[doc = " running event loops to terminate on the next opportunity."]
    #[doc = ""]
    #[doc = " @param se the session"]
    pub fn fuse_session_exit(se: *mut fuse_session);
}
extern "C" {
    #[doc = " Reset the terminated flag of a session"]
    #[doc = ""]
    #[doc = " @param se the session"]
    pub fn fuse_session_reset(se: *mut fuse_session);
}
extern "C" {
    #[doc = " Query the terminated flag of a session"]
    #[doc = ""]
    #[doc = " @param se the session"]
    #[doc = " @return 1 if exited, 0 if not exited"]
    pub fn fuse_session_exited(se: *mut fuse_session) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Ensure that file system is unmounted."]
    #[doc = ""]
    #[doc = " In regular operation, the file system is typically unmounted by the"]
    #[doc = " user calling umount(8) or fusermount(1), which then terminates the"]
    #[doc = " FUSE session loop. However, the session loop may also terminate as"]
    #[doc = " a result of an explicit call to fuse_session_exit() (e.g. by a"]
    #[doc = " signal handler installed by fuse_set_signal_handler()). In this"]
    #[doc = " case the filesystem remains mounted, but any attempt to access it"]
    #[doc = " will block (while the filesystem process is still running) or give"]
    #[doc = " an ESHUTDOWN error (after the filesystem process has terminated)."]
    #[doc = ""]
    #[doc = " If the communication channel with the FUSE kernel module is still"]
    #[doc = " open (i.e., if the session loop was terminated by an explicit call"]
    #[doc = " to fuse_session_exit()), this function will close it and unmount"]
    #[doc = " the filesystem. If the communication channel has been closed by the"]
    #[doc = " kernel, this method will do (almost) nothing."]
    #[doc = ""]
    #[doc = " NOTE: The above semantics mean that if the connection to the kernel"]
    #[doc = " is terminated via the ``/sys/fs/fuse/connections/NNN/abort`` file,"]
    #[doc = " this method will *not* unmount the filesystem."]
    #[doc = ""]
    #[doc = " @param se the session"]
    pub fn fuse_session_unmount(se: *mut fuse_session);
}
extern "C" {
    #[doc = " Destroy a session"]
    #[doc = ""]
    #[doc = " @param se the session"]
    pub fn fuse_session_destroy(se: *mut fuse_session);
}
extern "C" {
    #[doc = " Return file descriptor for communication with kernel."]
    #[doc = ""]
    #[doc = " The file selector can be used to integrate FUSE with a custom event"]
    #[doc = " loop. Whenever data is available for reading on the provided fd,"]
    #[doc = " the event loop should call `fuse_session_receive_buf` followed by"]
    #[doc = " `fuse_session_process_buf` to process the request."]
    #[doc = ""]
    #[doc = " The returned file descriptor is valid until `fuse_session_unmount`"]
    #[doc = " is called."]
    #[doc = ""]
    #[doc = " @param se the session"]
    #[doc = " @return a file descriptor"]
    pub fn fuse_session_fd(se: *mut fuse_session) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Process a raw request supplied in a generic buffer"]
    #[doc = ""]
    #[doc = " The fuse_buf may contain a memory buffer or a pipe file descriptor."]
    #[doc = ""]
    #[doc = " @param se the session"]
    #[doc = " @param buf the fuse_buf containing the request"]
    pub fn fuse_session_process_buf(se: *mut fuse_session, buf: *const fuse_buf);
}
extern "C" {
    #[doc = " Read a raw request from the kernel into the supplied buffer."]
    #[doc = ""]
    #[doc = " Depending on file system options, system capabilities, and request"]
    #[doc = " size the request is either read into a memory buffer or spliced"]
    #[doc = " into a temporary pipe."]
    #[doc = ""]
    #[doc = " @param se the session"]
    #[doc = " @param buf the fuse_buf to store the request in"]
    #[doc = " @return the actual size of the raw request, or -errno on error"]
    pub fn fuse_session_receive_buf(se: *mut fuse_session, buf: *mut fuse_buf) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cuse_info {
    pub dev_major: ::libc::c_uint,
    pub dev_minor: ::libc::c_uint,
    pub dev_info_argc: ::libc::c_uint,
    pub dev_info_argv: *mut *const ::libc::c_char,
    pub flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_cuse_info() {
    assert_eq!(
        ::std::mem::size_of::<cuse_info>(),
        32usize,
        concat!("Size of: ", stringify!(cuse_info))
    );
    assert_eq!(
        ::std::mem::align_of::<cuse_info>(),
        8usize,
        concat!("Alignment of ", stringify!(cuse_info))
    );
    fn test_field_dev_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_info),
                "::",
                stringify!(dev_major)
            )
        );
    }
    test_field_dev_major();
    fn test_field_dev_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_info),
                "::",
                stringify!(dev_minor)
            )
        );
    }
    test_field_dev_minor();
    fn test_field_dev_info_argc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_info_argc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_info),
                "::",
                stringify!(dev_info_argc)
            )
        );
    }
    test_field_dev_info_argc();
    fn test_field_dev_info_argv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_info_argv) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_info),
                "::",
                stringify!(dev_info_argv)
            )
        );
    }
    test_field_dev_info_argv();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_info),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cuse_lowlevel_ops {
    pub init: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::libc::c_void, conn: *mut fuse_conn_info),
    >,
    pub init_done: ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::libc::c_void)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(userdata: *mut ::libc::c_void)>,
    pub open: ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, fi: *mut fuse_file_info)>,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, size: size_t, off: off_t, fi: *mut fuse_file_info),
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            buf: *const ::libc::c_char,
            size: size_t,
            off: off_t,
            fi: *mut fuse_file_info,
        ),
    >,
    pub flush:
        ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, fi: *mut fuse_file_info)>,
    pub release:
        ::std::option::Option<unsafe extern "C" fn(req: fuse_req_t, fi: *mut fuse_file_info)>,
    pub fsync: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, datasync: ::libc::c_int, fi: *mut fuse_file_info),
    >,
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            req: fuse_req_t,
            cmd: ::libc::c_int,
            arg: *mut ::libc::c_void,
            fi: *mut fuse_file_info,
            flags: ::libc::c_uint,
            in_buf: *const ::libc::c_void,
            in_bufsz: size_t,
            out_bufsz: size_t,
        ),
    >,
    pub poll: ::std::option::Option<
        unsafe extern "C" fn(req: fuse_req_t, fi: *mut fuse_file_info, ph: *mut fuse_pollhandle),
    >,
}
#[test]
fn bindgen_test_layout_cuse_lowlevel_ops() {
    assert_eq!(
        ::std::mem::size_of::<cuse_lowlevel_ops>(),
        88usize,
        concat!("Size of: ", stringify!(cuse_lowlevel_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<cuse_lowlevel_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(cuse_lowlevel_ops))
    );
    fn test_field_init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(init)
            )
        );
    }
    test_field_init();
    fn test_field_init_done() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_done) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(init_done)
            )
        );
    }
    test_field_init_done();
    fn test_field_destroy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(destroy)
            )
        );
    }
    test_field_destroy();
    fn test_field_open() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(open)
            )
        );
    }
    test_field_open();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
    fn test_field_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(flush)
            )
        );
    }
    test_field_flush();
    fn test_field_release() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(release)
            )
        );
    }
    test_field_release();
    fn test_field_fsync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsync) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(fsync)
            )
        );
    }
    test_field_fsync();
    fn test_field_ioctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(ioctl)
            )
        );
    }
    test_field_ioctl();
    fn test_field_poll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_lowlevel_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_lowlevel_ops),
                "::",
                stringify!(poll)
            )
        );
    }
    test_field_poll();
}
extern "C" {
    pub fn cuse_lowlevel_new(
        args: *mut fuse_args,
        ci: *const cuse_info,
        clop: *const cuse_lowlevel_ops,
        userdata: *mut ::libc::c_void,
    ) -> *mut fuse_session;
}
extern "C" {
    pub fn cuse_lowlevel_setup(
        argc: ::libc::c_int,
        argv: *mut *mut ::libc::c_char,
        ci: *const cuse_info,
        clop: *const cuse_lowlevel_ops,
        multithreaded: *mut ::libc::c_int,
        userdata: *mut ::libc::c_void,
    ) -> *mut fuse_session;
}
extern "C" {
    pub fn cuse_lowlevel_teardown(se: *mut fuse_session);
}
extern "C" {
    pub fn cuse_lowlevel_main(
        argc: ::libc::c_int,
        argv: *mut *mut ::libc::c_char,
        ci: *const cuse_info,
        clop: *const cuse_lowlevel_ops,
        userdata: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
    pub tm_gmtoff: ::libc::c_long,
    pub tm_zone: *const ::libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerspec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerspec),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::libc::c_ushort,
    pub __ctype_tolower: *const ::libc::c_int,
    pub __ctype_toupper: *const ::libc::c_int,
    pub __names: [*const ::libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::libc::c_char,
        __maxsize: size_t,
        __format: *const ::libc::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::libc::c_char,
        __maxsize: size_t,
        __format: *const ::libc::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::libc::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::libc::c_int;
}
extern "C" {
    pub static mut __timezone: ::libc::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::libc::c_int;
}
extern "C" {
    pub static mut timezone: ::libc::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::libc::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::libc::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::libc::c_int) -> ::libc::c_int;
}
#[doc = " Handle for a FUSE filesystem"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse {
    _unused: [u8; 0],
}
#[doc = " \"Plus\" mode."]
#[doc = ""]
#[doc = " The kernel wants to prefill the inode cache during readdir.  The"]
#[doc = " filesystem may honour this by filling in the attributes and setting"]
#[doc = " FUSE_FILL_DIR_FLAGS for the filler function.  The filesystem may also"]
#[doc = " just ignore this flag completely."]
pub const fuse_readdir_flags_FUSE_READDIR_PLUS: fuse_readdir_flags = 1;
#[doc = " Readdir flags, passed to ->readdir()"]
pub type fuse_readdir_flags = ::libc::c_uint;
#[doc = " \"Plus\" mode: all file attributes are valid"]
#[doc = ""]
#[doc = " The attributes are used by the kernel to prefill the inode cache"]
#[doc = " during a readdir."]
#[doc = ""]
#[doc = " It is okay to set FUSE_FILL_DIR_PLUS if FUSE_READDIR_PLUS is not set"]
#[doc = " and vice versa."]
pub const fuse_fill_dir_flags_FUSE_FILL_DIR_PLUS: fuse_fill_dir_flags = 2;
#[doc = " Readdir flags, passed to fuse_fill_dir_t callback."]
pub type fuse_fill_dir_flags = ::libc::c_uint;
#[doc = " Function to add an entry in a readdir() operation"]
#[doc = ""]
#[doc = " The *off* parameter can be any non-zero value that enables the"]
#[doc = " filesystem to identify the current point in the directory"]
#[doc = " stream. It does not need to be the actual physical position. A"]
#[doc = " value of zero is reserved to indicate that seeking in directories"]
#[doc = " is not supported."]
#[doc = ""]
#[doc = " @param buf the buffer passed to the readdir() operation"]
#[doc = " @param name the file name of the directory entry"]
#[doc = " @param stbuf file attributes, can be NULL"]
#[doc = " @param off offset of the next entry or zero"]
#[doc = " @param flags fill flags"]
#[doc = " @return 1 if buffer is full, zero otherwise"]
pub type fuse_fill_dir_t = ::std::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::libc::c_void,
        name: *const ::libc::c_char,
        stbuf: *const stat,
        off: off_t,
        flags: fuse_fill_dir_flags,
    ) -> ::libc::c_int,
>;
#[doc = " Configuration of the high-level API"]
#[doc = ""]
#[doc = " This structure is initialized from the arguments passed to"]
#[doc = " fuse_new(), and then passed to the file system's init() handler"]
#[doc = " which should ensure that the configuration is compatible with the"]
#[doc = " file system implementation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_config {
    #[doc = " If `set_gid` is non-zero, the st_gid attribute of each file"]
    #[doc = " is overwritten with the value of `gid`."]
    pub set_gid: ::libc::c_int,
    pub gid: ::libc::c_uint,
    #[doc = " If `set_uid` is non-zero, the st_uid attribute of each file"]
    #[doc = " is overwritten with the value of `uid`."]
    pub set_uid: ::libc::c_int,
    pub uid: ::libc::c_uint,
    #[doc = " If `set_mode` is non-zero, the any permissions bits set in"]
    #[doc = " `umask` are unset in the st_mode attribute of each file."]
    pub set_mode: ::libc::c_int,
    pub umask: ::libc::c_uint,
    #[doc = " The timeout in seconds for which name lookups will be"]
    #[doc = " cached."]
    pub entry_timeout: f64,
    #[doc = " The timeout in seconds for which a negative lookup will be"]
    #[doc = " cached. This means, that if file did not exist (lookup"]
    #[doc = " returned ENOENT), the lookup will only be redone after the"]
    #[doc = " timeout, and the file/directory will be assumed to not"]
    #[doc = " exist until then. A value of zero means that negative"]
    #[doc = " lookups are not cached."]
    pub negative_timeout: f64,
    #[doc = " The timeout in seconds for which file/directory attributes"]
    #[doc = " (as returned by e.g. the `getattr` handler) are cached."]
    pub attr_timeout: f64,
    #[doc = " Allow requests to be interrupted"]
    pub intr: ::libc::c_int,
    #[doc = " Specify which signal number to send to the filesystem when"]
    #[doc = " a request is interrupted.  The default is hardcoded to"]
    #[doc = " USR1."]
    pub intr_signal: ::libc::c_int,
    #[doc = " Normally, FUSE assigns inodes to paths only for as long as"]
    #[doc = " the kernel is aware of them. With this option inodes are"]
    #[doc = " instead remembered for at least this many seconds.  This"]
    #[doc = " will require more memory, but may be necessary when using"]
    #[doc = " applications that make use of inode numbers."]
    #[doc = ""]
    #[doc = " A number of -1 means that inodes will be remembered for the"]
    #[doc = " entire life-time of the file-system process."]
    pub remember: ::libc::c_int,
    #[doc = " The default behavior is that if an open file is deleted,"]
    #[doc = " the file is renamed to a hidden file (.fuse_hiddenXXX), and"]
    #[doc = " only removed when the file is finally released.  This"]
    #[doc = " relieves the filesystem implementation of having to deal"]
    #[doc = " with this problem. This option disables the hiding"]
    #[doc = " behavior, and files are removed immediately in an unlink"]
    #[doc = " operation (or in a rename operation which overwrites an"]
    #[doc = " existing file)."]
    #[doc = ""]
    #[doc = " It is recommended that you not use the hard_remove"]
    #[doc = " option. When hard_remove is set, the following libc"]
    #[doc = " functions fail on unlinked files (returning errno of"]
    #[doc = " ENOENT): read(2), write(2), fsync(2), close(2), f*xattr(2),"]
    #[doc = " ftruncate(2), fstat(2), fchmod(2), fchown(2)"]
    pub hard_remove: ::libc::c_int,
    #[doc = " Honor the st_ino field in the functions getattr() and"]
    #[doc = " fill_dir(). This value is used to fill in the st_ino field"]
    #[doc = " in the stat(2), lstat(2), fstat(2) functions and the d_ino"]
    #[doc = " field in the readdir(2) function. The filesystem does not"]
    #[doc = " have to guarantee uniqueness, however some applications"]
    #[doc = " rely on this value being unique for the whole filesystem."]
    #[doc = ""]
    #[doc = " Note that this does *not* affect the inode that libfuse"]
    #[doc = " and the kernel use internally (also called the \"nodeid\")."]
    pub use_ino: ::libc::c_int,
    #[doc = " If use_ino option is not given, still try to fill in the"]
    #[doc = " d_ino field in readdir(2). If the name was previously"]
    #[doc = " looked up, and is still in the cache, the inode number"]
    #[doc = " found there will be used.  Otherwise it will be set to -1."]
    #[doc = " If use_ino option is given, this option is ignored."]
    pub readdir_ino: ::libc::c_int,
    #[doc = " This option disables the use of page cache (file content cache)"]
    #[doc = " in the kernel for this filesystem. This has several affects:"]
    #[doc = ""]
    #[doc = " 1. Each read(2) or write(2) system call will initiate one"]
    #[doc = "    or more read or write operations, data will not be"]
    #[doc = "    cached in the kernel."]
    #[doc = ""]
    #[doc = " 2. The return value of the read() and write() system calls"]
    #[doc = "    will correspond to the return values of the read and"]
    #[doc = "    write operations. This is useful for example if the"]
    #[doc = "    file size is not known in advance (before reading it)."]
    #[doc = ""]
    #[doc = " Internally, enabling this option causes fuse to set the"]
    #[doc = " `direct_io` field of `struct fuse_file_info` - overwriting"]
    #[doc = " any value that was put there by the file system."]
    pub direct_io: ::libc::c_int,
    #[doc = " This option disables flushing the cache of the file"]
    #[doc = " contents on every open(2).  This should only be enabled on"]
    #[doc = " filesystems where the file data is never changed"]
    #[doc = " externally (not through the mounted FUSE filesystem).  Thus"]
    #[doc = " it is not suitable for network filesystems and other"]
    #[doc = " intermediate filesystems."]
    #[doc = ""]
    #[doc = " NOTE: if this option is not specified (and neither"]
    #[doc = " direct_io) data is still cached after the open(2), so a"]
    #[doc = " read(2) system call will not always initiate a read"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " Internally, enabling this option causes fuse to set the"]
    #[doc = " `keep_cache` field of `struct fuse_file_info` - overwriting"]
    #[doc = " any value that was put there by the file system."]
    pub kernel_cache: ::libc::c_int,
    #[doc = " This option is an alternative to `kernel_cache`. Instead of"]
    #[doc = " unconditionally keeping cached data, the cached data is"]
    #[doc = " invalidated on open(2) if if the modification time or the"]
    #[doc = " size of the file has changed since it was last opened."]
    pub auto_cache: ::libc::c_int,
    #[doc = " By default, fuse waits for all pending writes to complete"]
    #[doc = " and calls the FLUSH operation on close(2) of every fuse fd."]
    #[doc = " With this option, wait and FLUSH are not done for read-only"]
    #[doc = " fuse fd, similar to the behavior of NFS/SMB clients."]
    pub no_rofd_flush: ::libc::c_int,
    #[doc = " The timeout in seconds for which file attributes are cached"]
    #[doc = " for the purpose of checking if auto_cache should flush the"]
    #[doc = " file data on open."]
    pub ac_attr_timeout_set: ::libc::c_int,
    pub ac_attr_timeout: f64,
    #[doc = " If this option is given the file-system handlers for the"]
    #[doc = " following operations will not receive path information:"]
    #[doc = " read, write, flush, release, fallocate, fsync, readdir,"]
    #[doc = " releasedir, fsyncdir, lock, ioctl and poll."]
    #[doc = ""]
    #[doc = " For the truncate, getattr, chmod, chown and utimens"]
    #[doc = " operations the path will be provided only if the struct"]
    #[doc = " fuse_file_info argument is NULL."]
    pub nullpath_ok: ::libc::c_int,
    #[doc = " The remaining options are used by libfuse internally and"]
    #[doc = " should not be touched."]
    pub show_help: ::libc::c_int,
    pub modules: *mut ::libc::c_char,
    pub debug: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_fuse_config() {
    assert_eq!(
        ::std::mem::size_of::<fuse_config>(),
        128usize,
        concat!("Size of: ", stringify!(fuse_config))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_config>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_config))
    );
    fn test_field_set_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_gid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(set_gid)
            )
        );
    }
    test_field_set_gid();
    fn test_field_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(gid)
            )
        );
    }
    test_field_gid();
    fn test_field_set_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_uid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(set_uid)
            )
        );
    }
    test_field_set_uid();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_set_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_mode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(set_mode)
            )
        );
    }
    test_field_set_mode();
    fn test_field_umask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(umask)
            )
        );
    }
    test_field_umask();
    fn test_field_entry_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_timeout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(entry_timeout)
            )
        );
    }
    test_field_entry_timeout();
    fn test_field_negative_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).negative_timeout) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(negative_timeout)
            )
        );
    }
    test_field_negative_timeout();
    fn test_field_attr_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr_timeout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(attr_timeout)
            )
        );
    }
    test_field_attr_timeout();
    fn test_field_intr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intr) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(intr)
            )
        );
    }
    test_field_intr();
    fn test_field_intr_signal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intr_signal) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(intr_signal)
            )
        );
    }
    test_field_intr_signal();
    fn test_field_remember() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remember) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(remember)
            )
        );
    }
    test_field_remember();
    fn test_field_hard_remove() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hard_remove) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(hard_remove)
            )
        );
    }
    test_field_hard_remove();
    fn test_field_use_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_ino) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(use_ino)
            )
        );
    }
    test_field_use_ino();
    fn test_field_readdir_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readdir_ino) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(readdir_ino)
            )
        );
    }
    test_field_readdir_ino();
    fn test_field_direct_io() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).direct_io) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(direct_io)
            )
        );
    }
    test_field_direct_io();
    fn test_field_kernel_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kernel_cache) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(kernel_cache)
            )
        );
    }
    test_field_kernel_cache();
    fn test_field_auto_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).auto_cache) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(auto_cache)
            )
        );
    }
    test_field_auto_cache();
    fn test_field_no_rofd_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).no_rofd_flush) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(no_rofd_flush)
            )
        );
    }
    test_field_no_rofd_flush();
    fn test_field_ac_attr_timeout_set() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_attr_timeout_set) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(ac_attr_timeout_set)
            )
        );
    }
    test_field_ac_attr_timeout_set();
    fn test_field_ac_attr_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ac_attr_timeout) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(ac_attr_timeout)
            )
        );
    }
    test_field_ac_attr_timeout();
    fn test_field_nullpath_ok() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nullpath_ok) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(nullpath_ok)
            )
        );
    }
    test_field_nullpath_ok();
    fn test_field_show_help() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).show_help) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(show_help)
            )
        );
    }
    test_field_show_help();
    fn test_field_modules() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modules) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(modules)
            )
        );
    }
    test_field_modules();
    fn test_field_debug() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_config),
                "::",
                stringify!(debug)
            )
        );
    }
    test_field_debug();
}
#[doc = " The file system operations:"]
#[doc = ""]
#[doc = " Most of these should work very similarly to the well known UNIX"]
#[doc = " file system operations.  A major exception is that instead of"]
#[doc = " returning an error in 'errno', the operation should return the"]
#[doc = " negated error value (-errno) directly."]
#[doc = ""]
#[doc = " All methods are optional, but some are essential for a useful"]
#[doc = " filesystem (e.g. getattr).  Open, flush, release, fsync, opendir,"]
#[doc = " releasedir, fsyncdir, access, create, truncate, lock, init and"]
#[doc = " destroy are special purpose methods, without which a full featured"]
#[doc = " filesystem can still be implemented."]
#[doc = ""]
#[doc = " In general, all methods are expected to perform any necessary"]
#[doc = " permission checking. However, a filesystem may delegate this task"]
#[doc = " to the kernel by passing the `default_permissions` mount option to"]
#[doc = " `fuse_new()`. In this case, methods will only be called if"]
#[doc = " the kernel's permission check has succeeded."]
#[doc = ""]
#[doc = " Almost all operations take a path which can be of any length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_operations {
    #[doc = " Get file attributes."]
    #[doc = ""]
    #[doc = " Similar to stat().  The 'st_dev' and 'st_blksize' fields are"]
    #[doc = " ignored. The 'st_ino' field is ignored except if the 'use_ino'"]
    #[doc = " mount option is given. In that case it is passed to userspace,"]
    #[doc = " but libfuse and the kernel will still assign a different"]
    #[doc = " inode for internal use (called the \"nodeid\")."]
    #[doc = ""]
    #[doc = " `fi` will always be NULL if the file is not currently open, but"]
    #[doc = " may also be NULL if the file is open."]
    pub getattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut stat,
            fi: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Read the target of a symbolic link"]
    #[doc = ""]
    #[doc = " The buffer should be filled with a null terminated string.  The"]
    #[doc = " buffer size argument includes the space for the terminating"]
    #[doc = " null character.\tIf the linkname is too long to fit in the"]
    #[doc = " buffer, it should be truncated.\tThe return value should be 0"]
    #[doc = " for success."]
    pub readlink: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut ::libc::c_char,
            arg3: size_t,
        ) -> ::libc::c_int,
    >,
    #[doc = " Create a file node"]
    #[doc = ""]
    #[doc = " This is called for creation of all non-directory, non-symlink"]
    #[doc = " nodes.  If the filesystem defines a create() method, then for"]
    #[doc = " regular files that will be called instead."]
    pub mknod: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: mode_t,
            arg3: dev_t,
        ) -> ::libc::c_int,
    >,
    #[doc = " Create a directory"]
    #[doc = ""]
    #[doc = " Note that the mode argument may not have the type specification"]
    #[doc = " bits set, i.e. S_ISDIR(mode) can be false.  To obtain the"]
    #[doc = " correct directory type bits use  mode|S_IFDIR"]
    pub mkdir: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::libc::c_char, arg2: mode_t) -> ::libc::c_int,
    >,
    #[doc = " Remove a file"]
    pub unlink:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_char) -> ::libc::c_int>,
    #[doc = " Remove a directory"]
    pub rmdir:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_char) -> ::libc::c_int>,
    #[doc = " Create a symbolic link"]
    pub symlink: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
        ) -> ::libc::c_int,
    >,
    #[doc = " Rename a file"]
    #[doc = ""]
    #[doc = " *flags* may be `RENAME_EXCHANGE` or `RENAME_NOREPLACE`. If"]
    #[doc = " RENAME_NOREPLACE is specified, the filesystem must not"]
    #[doc = " overwrite *newname* if it exists and return an error"]
    #[doc = " instead. If `RENAME_EXCHANGE` is specified, the filesystem"]
    #[doc = " must atomically exchange the two files, i.e. both must"]
    #[doc = " exist and neither may be deleted."]
    pub rename: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
            flags: ::libc::c_uint,
        ) -> ::libc::c_int,
    >,
    #[doc = " Create a hard link to a file"]
    pub link: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
        ) -> ::libc::c_int,
    >,
    #[doc = " Change the permission bits of a file"]
    #[doc = ""]
    #[doc = " `fi` will always be NULL if the file is not currently open, but"]
    #[doc = " may also be NULL if the file is open."]
    pub chmod: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: mode_t,
            fi: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Change the owner and group of a file"]
    #[doc = ""]
    #[doc = " `fi` will always be NULL if the file is not currently open, but"]
    #[doc = " may also be NULL if the file is open."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits."]
    pub chown: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: uid_t,
            arg3: gid_t,
            fi: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Change the size of a file"]
    #[doc = ""]
    #[doc = " `fi` will always be NULL if the file is not currently open, but"]
    #[doc = " may also be NULL if the file is open."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits."]
    pub truncate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: off_t,
            fi: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Open a file"]
    #[doc = ""]
    #[doc = " Open flags are available in fi->flags. The following rules"]
    #[doc = " apply."]
    #[doc = ""]
    #[doc = "  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be"]
    #[doc = "    filtered out / handled by the kernel."]
    #[doc = ""]
    #[doc = "  - Access modes (O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH)"]
    #[doc = "    should be used by the filesystem to check if the operation is"]
    #[doc = "    permitted.  If the ``-o default_permissions`` mount option is"]
    #[doc = "    given, this check is already done by the kernel before calling"]
    #[doc = "    open() and may thus be omitted by the filesystem."]
    #[doc = ""]
    #[doc = "  - When writeback caching is enabled, the kernel may send"]
    #[doc = "    read requests even for files opened with O_WRONLY. The"]
    #[doc = "    filesystem should be prepared to handle this."]
    #[doc = ""]
    #[doc = "  - When writeback caching is disabled, the filesystem is"]
    #[doc = "    expected to properly handle the O_APPEND flag and ensure"]
    #[doc = "    that each write is appending to the end of the file."]
    #[doc = ""]
    #[doc = "  - When writeback caching is enabled, the kernel will"]
    #[doc = "    handle O_APPEND. However, unless all changes to the file"]
    #[doc = "    come through the kernel this will not work reliably. The"]
    #[doc = "    filesystem should thus either ignore the O_APPEND flag"]
    #[doc = "    (and let the kernel handle it), or return an error"]
    #[doc = "    (indicating that reliably O_APPEND is not available)."]
    #[doc = ""]
    #[doc = " Filesystem may store an arbitrary file handle (pointer,"]
    #[doc = " index, etc) in fi->fh, and use this in other all other file"]
    #[doc = " operations (read, write, flush, release, fsync)."]
    #[doc = ""]
    #[doc = " Filesystem may also implement stateless file I/O and not store"]
    #[doc = " anything in fi->fh."]
    #[doc = ""]
    #[doc = " There are also some flags (direct_io, keep_cache) which the"]
    #[doc = " filesystem may set in fi, to change the way the file is opened."]
    #[doc = " See fuse_file_info structure in <fuse_common.h> for more details."]
    #[doc = ""]
    #[doc = " If this request is answered with an error code of ENOSYS"]
    #[doc = " and FUSE_CAP_NO_OPEN_SUPPORT is set in"]
    #[doc = " `fuse_conn_info.capable`, this is treated as success and"]
    #[doc = " future calls to open will also succeed without being send"]
    #[doc = " to the filesystem process."]
    #[doc = ""]
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Read data from an open file"]
    #[doc = ""]
    #[doc = " Read should return exactly the number of bytes requested except"]
    #[doc = " on EOF or error, otherwise the rest of the data will be"]
    #[doc = " substituted with zeroes.\t An exception to this is when the"]
    #[doc = " 'direct_io' mount option is specified, in which case the return"]
    #[doc = " value of the read system call will reflect the return value of"]
    #[doc = " this operation."]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut ::libc::c_char,
            arg3: size_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Write data to an open file"]
    #[doc = ""]
    #[doc = " Write should return exactly the number of bytes requested"]
    #[doc = " except on error.\t An exception to this is when the 'direct_io'"]
    #[doc = " mount option is specified (see read operation)."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits."]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
            arg3: size_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Get file system statistics"]
    #[doc = ""]
    #[doc = " The 'f_favail', 'f_fsid' and 'f_flag' fields are ignored"]
    pub statfs: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::libc::c_char, arg2: *mut statvfs) -> ::libc::c_int,
    >,
    #[doc = " Possibly flush cached data"]
    #[doc = ""]
    #[doc = " BIG NOTE: This is not equivalent to fsync().  It's not a"]
    #[doc = " request to sync dirty data."]
    #[doc = ""]
    #[doc = " Flush is called on each close() of a file descriptor, as opposed to"]
    #[doc = " release which is called on the close of the last file descriptor for"]
    #[doc = " a file.  Under Linux, errors returned by flush() will be passed to"]
    #[doc = " userspace as errors from close(), so flush() is a good place to write"]
    #[doc = " back any cached dirty data. However, many applications ignore errors"]
    #[doc = " on close(), and on non-Linux systems, close() may succeed even if flush()"]
    #[doc = " returns an error. For these reasons, filesystems should not assume"]
    #[doc = " that errors returned by flush will ever be noticed or even"]
    #[doc = " delivered."]
    #[doc = ""]
    #[doc = " NOTE: The flush() method may be called more than once for each"]
    #[doc = " open().  This happens if more than one file descriptor refers to an"]
    #[doc = " open file handle, e.g. due to dup(), dup2() or fork() calls.  It is"]
    #[doc = " not possible to determine if a flush is final, so each flush should"]
    #[doc = " be treated equally.  Multiple write-flush sequences are relatively"]
    #[doc = " rare, so this shouldn't be a problem."]
    #[doc = ""]
    #[doc = " Filesystems shouldn't assume that flush will be called at any"]
    #[doc = " particular point.  It may be called more times than expected, or not"]
    #[doc = " at all."]
    #[doc = ""]
    #[doc = " [close]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html"]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Release an open file"]
    #[doc = ""]
    #[doc = " Release is called when there are no more references to an open"]
    #[doc = " file: all file descriptors are closed and all memory mappings"]
    #[doc = " are unmapped."]
    #[doc = ""]
    #[doc = " For every open() call there will be exactly one release() call"]
    #[doc = " with the same flags and file handle.  It is possible to"]
    #[doc = " have a file opened more than once, in which case only the last"]
    #[doc = " release will mean, that no more reads/writes will happen on the"]
    #[doc = " file.  The return value of release is ignored."]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Synchronize file contents"]
    #[doc = ""]
    #[doc = " If the datasync parameter is non-zero, then only the user data"]
    #[doc = " should be flushed, not the meta data."]
    pub fsync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: ::libc::c_int,
            arg3: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Set extended attributes"]
    pub setxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
            arg3: *const ::libc::c_char,
            arg4: size_t,
            arg5: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    #[doc = " Get extended attributes"]
    pub getxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
            arg3: *mut ::libc::c_char,
            arg4: size_t,
        ) -> ::libc::c_int,
    >,
    #[doc = " List extended attributes"]
    pub listxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut ::libc::c_char,
            arg3: size_t,
        ) -> ::libc::c_int,
    >,
    #[doc = " Remove extended attributes"]
    pub removexattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *const ::libc::c_char,
        ) -> ::libc::c_int,
    >,
    #[doc = " Open directory"]
    #[doc = ""]
    #[doc = " Unless the 'default_permissions' mount option is given,"]
    #[doc = " this method should check if opendir is permitted for this"]
    #[doc = " directory. Optionally opendir may also return an arbitrary"]
    #[doc = " filehandle in the fuse_file_info structure, which will be"]
    #[doc = " passed to readdir, releasedir and fsyncdir."]
    pub opendir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Read directory"]
    #[doc = ""]
    #[doc = " The filesystem may choose between two modes of operation:"]
    #[doc = ""]
    #[doc = " 1) The readdir implementation ignores the offset parameter, and"]
    #[doc = " passes zero to the filler function's offset.  The filler"]
    #[doc = " function will not return '1' (unless an error happens), so the"]
    #[doc = " whole directory is read in a single readdir operation."]
    #[doc = ""]
    #[doc = " 2) The readdir implementation keeps track of the offsets of the"]
    #[doc = " directory entries.  It uses the offset parameter and always"]
    #[doc = " passes non-zero offset to the filler function.  When the buffer"]
    #[doc = " is full (or an error happens) the filler function will return"]
    #[doc = " '1'."]
    #[doc = ""]
    #[doc = " When FUSE_READDIR_PLUS is not set, only some parameters of the"]
    #[doc = " fill function (the fuse_fill_dir_t parameter) are actually used:"]
    #[doc = " The file type (which is part of stat::st_mode) is used. And if"]
    #[doc = " fuse_config::use_ino is set, the inode (stat::st_ino) is also"]
    #[doc = " used. The other fields are ignored when FUSE_READDIR_PLUS is not"]
    #[doc = " set."]
    pub readdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut ::libc::c_void,
            arg3: fuse_fill_dir_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
            arg6: fuse_readdir_flags,
        ) -> ::libc::c_int,
    >,
    #[doc = " Release directory"]
    #[doc = ""]
    #[doc = " If the directory has been removed after the call to opendir, the"]
    #[doc = " path parameter will be NULL."]
    pub releasedir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Synchronize directory contents"]
    #[doc = ""]
    #[doc = " If the directory has been removed after the call to opendir, the"]
    #[doc = " path parameter will be NULL."]
    #[doc = ""]
    #[doc = " If the datasync parameter is non-zero, then only the user data"]
    #[doc = " should be flushed, not the meta data"]
    pub fsyncdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: ::libc::c_int,
            arg3: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Initialize filesystem"]
    #[doc = ""]
    #[doc = " The return value will passed in the `private_data` field of"]
    #[doc = " `struct fuse_context` to all file operations, and as a"]
    #[doc = " parameter to the destroy() method. It overrides the initial"]
    #[doc = " value provided to fuse_main() / fuse_new()."]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut fuse_conn_info,
            cfg: *mut fuse_config,
        ) -> *mut ::libc::c_void,
    >,
    #[doc = " Clean up filesystem"]
    #[doc = ""]
    #[doc = " Called on filesystem exit."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(private_data: *mut ::libc::c_void)>,
    #[doc = " Check file access permissions"]
    #[doc = ""]
    #[doc = " This will be called for the access() system call.  If the"]
    #[doc = " 'default_permissions' mount option is given, this method is not"]
    #[doc = " called."]
    #[doc = ""]
    #[doc = " This method is not called under Linux kernel versions 2.4.x"]
    pub access: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> ::libc::c_int,
    >,
    #[doc = " Create and open a file"]
    #[doc = ""]
    #[doc = " If the file does not exist, first create it with the specified"]
    #[doc = " mode, and then open it."]
    #[doc = ""]
    #[doc = " If this method is not implemented or under Linux kernel"]
    #[doc = " versions earlier than 2.6.15, the mknod() and open() methods"]
    #[doc = " will be called instead."]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: mode_t,
            arg3: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Perform POSIX file locking operation"]
    #[doc = ""]
    #[doc = " The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW."]
    #[doc = ""]
    #[doc = " For the meaning of fields in 'struct flock' see the man page"]
    #[doc = " for fcntl(2).  The l_whence field will always be set to"]
    #[doc = " SEEK_SET."]
    #[doc = ""]
    #[doc = " For checking lock ownership, the 'fuse_file_info->owner'"]
    #[doc = " argument must be used."]
    #[doc = ""]
    #[doc = " For F_GETLK operation, the library will first check currently"]
    #[doc = " held locks, and if a conflicting lock is found it will return"]
    #[doc = " information without calling this method.\t This ensures, that"]
    #[doc = " for local locks the l_pid field is correctly filled in.\tThe"]
    #[doc = " results may not be accurate in case of race conditions and in"]
    #[doc = " the presence of hard links, but it's unlikely that an"]
    #[doc = " application would rely on accurate GETLK results in these"]
    #[doc = " cases.  If a conflicting lock is not found, this method will be"]
    #[doc = " called, and the filesystem may fill out l_pid by a meaningful"]
    #[doc = " value, or it may leave this field zero."]
    #[doc = ""]
    #[doc = " For F_SETLK and F_SETLKW the l_pid field will be set to the pid"]
    #[doc = " of the process performing the locking operation."]
    #[doc = ""]
    #[doc = " Note: if this method is not implemented, the kernel will still"]
    #[doc = " allow file locking to work locally.  Hence it is only"]
    #[doc = " interesting for network filesystems and similar."]
    pub lock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
            cmd: ::libc::c_int,
            arg3: *mut flock,
        ) -> ::libc::c_int,
    >,
    #[doc = " Change the access and modification times of a file with"]
    #[doc = " nanosecond resolution"]
    #[doc = ""]
    #[doc = " This supersedes the old utime() interface.  New applications"]
    #[doc = " should use this."]
    #[doc = ""]
    #[doc = " `fi` will always be NULL if the file is not currently open, but"]
    #[doc = " may also be NULL if the file is open."]
    #[doc = ""]
    #[doc = " See the utimensat(2) man page for details."]
    pub utimens: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            tv: *const timespec,
            fi: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Map block index within file to block index within device"]
    #[doc = ""]
    #[doc = " Note: This makes sense only for block device backed filesystems"]
    #[doc = " mounted with the 'blkdev' option"]
    pub bmap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            blocksize: size_t,
            idx: *mut u64,
        ) -> ::libc::c_int,
    >,
    #[doc = " Ioctl"]
    #[doc = ""]
    #[doc = " flags will have FUSE_IOCTL_COMPAT set for 32bit ioctls in"]
    #[doc = " 64bit environment.  The size and direction of data is"]
    #[doc = " determined by _IOC_*() decoding of cmd.  For _IOC_NONE,"]
    #[doc = " data will be NULL, for _IOC_WRITE data is out area, for"]
    #[doc = " _IOC_READ in area and if both are set in/out area.  In all"]
    #[doc = " non-NULL cases, the area is of _IOC_SIZE(cmd) bytes."]
    #[doc = ""]
    #[doc = " If flags has FUSE_IOCTL_DIR then the fuse_file_info refers to a"]
    #[doc = " directory file handle."]
    #[doc = ""]
    #[doc = " Note : the unsigned long request submitted by the application"]
    #[doc = " is truncated to 32 bits."]
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            cmd: ::libc::c_uint,
            arg: *mut ::libc::c_void,
            arg2: *mut fuse_file_info,
            flags: ::libc::c_uint,
            data: *mut ::libc::c_void,
        ) -> ::libc::c_int,
    >,
    #[doc = " Poll for IO readiness events"]
    #[doc = ""]
    #[doc = " Note: If ph is non-NULL, the client should notify"]
    #[doc = " when IO readiness events occur by calling"]
    #[doc = " fuse_notify_poll() with the specified ph."]
    #[doc = ""]
    #[doc = " Regardless of the number of times poll with a non-NULL ph"]
    #[doc = " is received, single notification is enough to clear all."]
    #[doc = " Notifying more times incurs overhead but doesn't harm"]
    #[doc = " correctness."]
    #[doc = ""]
    #[doc = " The callee is responsible for destroying ph with"]
    #[doc = " fuse_pollhandle_destroy() when no longer in use."]
    pub poll: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
            ph: *mut fuse_pollhandle,
            reventsp: *mut ::libc::c_uint,
        ) -> ::libc::c_int,
    >,
    #[doc = " Write contents of buffer to an open file"]
    #[doc = ""]
    #[doc = " Similar to the write() method, but data is supplied in a"]
    #[doc = " generic buffer.  Use fuse_buf_copy() to transfer data to"]
    #[doc = " the destination."]
    #[doc = ""]
    #[doc = " Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is"]
    #[doc = " expected to reset the setuid and setgid bits."]
    pub write_buf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            buf: *mut fuse_bufvec,
            off: off_t,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Store data from an open file in a buffer"]
    #[doc = ""]
    #[doc = " Similar to the read() method, but data is stored and"]
    #[doc = " returned in a generic buffer."]
    #[doc = ""]
    #[doc = " No actual copying of data has to take place, the source"]
    #[doc = " file descriptor may simply be stored in the buffer for"]
    #[doc = " later data transfer."]
    #[doc = ""]
    #[doc = " The buffer must be allocated dynamically and stored at the"]
    #[doc = " location pointed to by bufp.  If the buffer contains memory"]
    #[doc = " regions, they too must be allocated using malloc().  The"]
    #[doc = " allocated memory will be freed by the caller."]
    pub read_buf: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            bufp: *mut *mut fuse_bufvec,
            size: size_t,
            off: off_t,
            arg2: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Perform BSD file locking operation"]
    #[doc = ""]
    #[doc = " The op argument will be either LOCK_SH, LOCK_EX or LOCK_UN"]
    #[doc = ""]
    #[doc = " Nonblocking requests will be indicated by ORing LOCK_NB to"]
    #[doc = " the above operations"]
    #[doc = ""]
    #[doc = " For more information see the flock(2) manual page."]
    #[doc = ""]
    #[doc = " Additionally fi->owner will be set to a value unique to"]
    #[doc = " this open file.  This same value will be supplied to"]
    #[doc = " ->release() when the file is released."]
    #[doc = ""]
    #[doc = " Note: if this method is not implemented, the kernel will still"]
    #[doc = " allow file locking to work locally.  Hence it is only"]
    #[doc = " interesting for network filesystems and similar."]
    pub flock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: *mut fuse_file_info,
            op: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    #[doc = " Allocates space for an open file"]
    #[doc = ""]
    #[doc = " This function ensures that required space is allocated for specified"]
    #[doc = " file.  If this function returns success then any subsequent write"]
    #[doc = " request to specified range is guaranteed not to fail because of lack"]
    #[doc = " of space on the file system media."]
    pub fallocate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            arg2: ::libc::c_int,
            arg3: off_t,
            arg4: off_t,
            arg5: *mut fuse_file_info,
        ) -> ::libc::c_int,
    >,
    #[doc = " Copy a range of data from one file to another"]
    #[doc = ""]
    #[doc = " Performs an optimized copy between two file descriptors without the"]
    #[doc = " additional cost of transferring data through the FUSE kernel module"]
    #[doc = " to user space (glibc) and then back into the FUSE filesystem again."]
    #[doc = ""]
    #[doc = " In case this method is not implemented, applications are expected to"]
    #[doc = " fall back to a regular file copy.   (Some glibc versions did this"]
    #[doc = " emulation automatically, but the emulation has been removed from all"]
    #[doc = " glibc release branches.)"]
    pub copy_file_range: ::std::option::Option<
        unsafe extern "C" fn(
            path_in: *const ::libc::c_char,
            fi_in: *mut fuse_file_info,
            offset_in: off_t,
            path_out: *const ::libc::c_char,
            fi_out: *mut fuse_file_info,
            offset_out: off_t,
            size: size_t,
            flags: ::libc::c_int,
        ) -> ssize_t,
    >,
    #[doc = " Find next data or hole after the specified offset"]
    pub lseek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_char,
            off: off_t,
            whence: ::libc::c_int,
            arg2: *mut fuse_file_info,
        ) -> off_t,
    >,
}
#[test]
fn bindgen_test_layout_fuse_operations() {
    assert_eq!(
        ::std::mem::size_of::<fuse_operations>(),
        336usize,
        concat!("Size of: ", stringify!(fuse_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_operations))
    );
    fn test_field_getattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getattr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(getattr)
            )
        );
    }
    test_field_getattr();
    fn test_field_readlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readlink) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(readlink)
            )
        );
    }
    test_field_readlink();
    fn test_field_mknod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mknod) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(mknod)
            )
        );
    }
    test_field_mknod();
    fn test_field_mkdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mkdir) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(mkdir)
            )
        );
    }
    test_field_mkdir();
    fn test_field_unlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unlink) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(unlink)
            )
        );
    }
    test_field_unlink();
    fn test_field_rmdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rmdir) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(rmdir)
            )
        );
    }
    test_field_rmdir();
    fn test_field_symlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).symlink) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(symlink)
            )
        );
    }
    test_field_symlink();
    fn test_field_rename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rename) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(rename)
            )
        );
    }
    test_field_rename();
    fn test_field_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(link)
            )
        );
    }
    test_field_link();
    fn test_field_chmod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chmod) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(chmod)
            )
        );
    }
    test_field_chmod();
    fn test_field_chown() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chown) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(chown)
            )
        );
    }
    test_field_chown();
    fn test_field_truncate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).truncate) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(truncate)
            )
        );
    }
    test_field_truncate();
    fn test_field_open() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(open)
            )
        );
    }
    test_field_open();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
    fn test_field_statfs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statfs) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(statfs)
            )
        );
    }
    test_field_statfs();
    fn test_field_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(flush)
            )
        );
    }
    test_field_flush();
    fn test_field_release() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(release)
            )
        );
    }
    test_field_release();
    fn test_field_fsync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsync) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(fsync)
            )
        );
    }
    test_field_fsync();
    fn test_field_setxattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setxattr) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(setxattr)
            )
        );
    }
    test_field_setxattr();
    fn test_field_getxattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getxattr) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(getxattr)
            )
        );
    }
    test_field_getxattr();
    fn test_field_listxattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).listxattr) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(listxattr)
            )
        );
    }
    test_field_listxattr();
    fn test_field_removexattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).removexattr) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(removexattr)
            )
        );
    }
    test_field_removexattr();
    fn test_field_opendir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opendir) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(opendir)
            )
        );
    }
    test_field_opendir();
    fn test_field_readdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).readdir) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(readdir)
            )
        );
    }
    test_field_readdir();
    fn test_field_releasedir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).releasedir) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(releasedir)
            )
        );
    }
    test_field_releasedir();
    fn test_field_fsyncdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsyncdir) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(fsyncdir)
            )
        );
    }
    test_field_fsyncdir();
    fn test_field_init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(init)
            )
        );
    }
    test_field_init();
    fn test_field_destroy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(destroy)
            )
        );
    }
    test_field_destroy();
    fn test_field_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(access)
            )
        );
    }
    test_field_access();
    fn test_field_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(create)
            )
        );
    }
    test_field_create();
    fn test_field_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(lock)
            )
        );
    }
    test_field_lock();
    fn test_field_utimens() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).utimens) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(utimens)
            )
        );
    }
    test_field_utimens();
    fn test_field_bmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bmap) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(bmap)
            )
        );
    }
    test_field_bmap();
    fn test_field_ioctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(ioctl)
            )
        );
    }
    test_field_ioctl();
    fn test_field_poll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poll) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(poll)
            )
        );
    }
    test_field_poll();
    fn test_field_write_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(write_buf)
            )
        );
    }
    test_field_write_buf();
    fn test_field_read_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_buf) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(read_buf)
            )
        );
    }
    test_field_read_buf();
    fn test_field_flock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flock) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(flock)
            )
        );
    }
    test_field_flock();
    fn test_field_fallocate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fallocate) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(fallocate)
            )
        );
    }
    test_field_fallocate();
    fn test_field_copy_file_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy_file_range) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(copy_file_range)
            )
        );
    }
    test_field_copy_file_range();
    fn test_field_lseek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_operations>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lseek) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_operations),
                "::",
                stringify!(lseek)
            )
        );
    }
    test_field_lseek();
}
#[doc = " Extra context that may be needed by some filesystems"]
#[doc = ""]
#[doc = " The uid, gid and pid fields are not filled in case of a writepage"]
#[doc = " operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_context {
    #[doc = " Pointer to the fuse object"]
    pub fuse: *mut fuse,
    #[doc = " User ID of the calling process"]
    pub uid: uid_t,
    #[doc = " Group ID of the calling process"]
    pub gid: gid_t,
    #[doc = " Process ID of the calling thread"]
    pub pid: pid_t,
    #[doc = " Private filesystem data"]
    pub private_data: *mut ::libc::c_void,
    #[doc = " Umask of the calling process"]
    pub umask: mode_t,
}
#[test]
fn bindgen_test_layout_fuse_context() {
    assert_eq!(
        ::std::mem::size_of::<fuse_context>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_context))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_context>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_context))
    );
    fn test_field_fuse() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fuse) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_context),
                "::",
                stringify!(fuse)
            )
        );
    }
    test_field_fuse();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_context),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_context),
                "::",
                stringify!(gid)
            )
        );
    }
    test_field_gid();
    fn test_field_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_context),
                "::",
                stringify!(pid)
            )
        );
    }
    test_field_pid();
    fn test_field_private_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_context),
                "::",
                stringify!(private_data)
            )
        );
    }
    test_field_private_data();
    fn test_field_umask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_context>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_context),
                "::",
                stringify!(umask)
            )
        );
    }
    test_field_umask();
}
extern "C" {
    #[doc = " Print available options (high- and low-level) to stdout.  This is"]
    #[doc = " not an exhaustive list, but includes only those options that may be"]
    #[doc = " of interest to an end-user of a file system."]
    #[doc = ""]
    #[doc = " The function looks at the argument vector only to determine if"]
    #[doc = " there are additional modules to be loaded (module=foo option),"]
    #[doc = " and attempts to call their help functions as well."]
    #[doc = ""]
    #[doc = " @param args the argument vector."]
    pub fn fuse_lib_help(args: *mut fuse_args);
}
extern "C" {
    pub fn fuse_new(
        args: *mut fuse_args,
        op: *const fuse_operations,
        op_size: size_t,
        private_data: *mut ::libc::c_void,
    ) -> *mut fuse;
}
extern "C" {
    #[doc = " Mount a FUSE file system."]
    #[doc = ""]
    #[doc = " @param mountpoint the mount point path"]
    #[doc = " @param f the FUSE handle"]
    #[doc = ""]
    #[doc = " @return 0 on success, -1 on failure."]
    pub fn fuse_mount(f: *mut fuse, mountpoint: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Unmount a FUSE file system."]
    #[doc = ""]
    #[doc = " See fuse_session_unmount() for additional information."]
    #[doc = ""]
    #[doc = " @param f the FUSE handle"]
    pub fn fuse_unmount(f: *mut fuse);
}
extern "C" {
    #[doc = " Destroy the FUSE handle."]
    #[doc = ""]
    #[doc = " NOTE: This function does not unmount the filesystem.\t If this is"]
    #[doc = " needed, call fuse_unmount() before calling this function."]
    #[doc = ""]
    #[doc = " @param f the FUSE handle"]
    pub fn fuse_destroy(f: *mut fuse);
}
extern "C" {
    #[doc = " FUSE event loop."]
    #[doc = ""]
    #[doc = " Requests from the kernel are processed, and the appropriate"]
    #[doc = " operations are called."]
    #[doc = ""]
    #[doc = " For a description of the return value and the conditions when the"]
    #[doc = " event loop exits, refer to the documentation of"]
    #[doc = " fuse_session_loop()."]
    #[doc = ""]
    #[doc = " @param f the FUSE handle"]
    #[doc = " @return see fuse_session_loop()"]
    #[doc = ""]
    #[doc = " See also: fuse_loop_mt()"]
    pub fn fuse_loop(f: *mut fuse) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Flag session as terminated"]
    #[doc = ""]
    #[doc = " This function will cause any running event loops to exit on"]
    #[doc = " the next opportunity."]
    #[doc = ""]
    #[doc = " @param f the FUSE handle"]
    pub fn fuse_exit(f: *mut fuse);
}
extern "C" {
    #[doc = " FUSE event loop with multiple threads"]
    #[doc = ""]
    #[doc = " Requests from the kernel are processed, and the appropriate"]
    #[doc = " operations are called.  Request are processed in parallel by"]
    #[doc = " distributing them between multiple threads."]
    #[doc = ""]
    #[doc = " For a description of the return value and the conditions when the"]
    #[doc = " event loop exits, refer to the documentation of"]
    #[doc = " fuse_session_loop()."]
    #[doc = ""]
    #[doc = " Note: using fuse_loop() instead of fuse_loop_mt() means you are running in"]
    #[doc = " single-threaded mode, and that you will not have to worry about reentrancy,"]
    #[doc = " though you will have to worry about recursive lookups. In single-threaded"]
    #[doc = " mode, FUSE will wait for one callback to return before calling another."]
    #[doc = ""]
    #[doc = " Enabling multiple threads, by using fuse_loop_mt(), will cause FUSE to make"]
    #[doc = " multiple simultaneous calls into the various callback functions given by your"]
    #[doc = " fuse_operations record."]
    #[doc = ""]
    #[doc = " If you are using multiple threads, you can enjoy all the parallel execution"]
    #[doc = " and interactive response benefits of threads, and you get to enjoy all the"]
    #[doc = " benefits of race conditions and locking bugs, too. Ensure that any code used"]
    #[doc = " in the callback function of fuse_operations is also thread-safe."]
    #[doc = ""]
    #[doc = " @param f the FUSE handle"]
    #[doc = " @param config loop configuration, may be NULL and defaults will be used then"]
    #[doc = " @return see fuse_session_loop()"]
    #[doc = ""]
    #[doc = " See also: fuse_loop()"]
    pub fn fuse_loop_mt(f: *mut fuse, config: *mut fuse_loop_config) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current context"]
    #[doc = ""]
    #[doc = " The context is only valid for the duration of a filesystem"]
    #[doc = " operation, and thus must not be stored and used later."]
    #[doc = ""]
    #[doc = " @return the context"]
    pub fn fuse_get_context() -> *mut fuse_context;
}
extern "C" {
    #[doc = " Get the current supplementary group IDs for the current request"]
    #[doc = ""]
    #[doc = " Similar to the getgroups(2) system call, except the return value is"]
    #[doc = " always the total number of group IDs, even if it is larger than the"]
    #[doc = " specified size."]
    #[doc = ""]
    #[doc = " The current fuse kernel module in linux (as of 2.6.30) doesn't pass"]
    #[doc = " the group list to userspace, hence this function needs to parse"]
    #[doc = " \"/proc/$TID/task/$TID/status\" to get the group IDs."]
    #[doc = ""]
    #[doc = " This feature may not be supported on all operating systems.  In"]
    #[doc = " such a case this function will return -ENOSYS."]
    #[doc = ""]
    #[doc = " @param size size of given array"]
    #[doc = " @param list array of group IDs to be filled in"]
    #[doc = " @return the total number of supplementary group IDs or -errno on failure"]
    pub fn fuse_getgroups(size: ::libc::c_int, list: *mut gid_t) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Check if the current request has already been interrupted"]
    #[doc = ""]
    #[doc = " @return 1 if the request has been interrupted, 0 otherwise"]
    pub fn fuse_interrupted() -> ::libc::c_int;
}
extern "C" {
    #[doc = " Invalidates cache for the given path."]
    #[doc = ""]
    #[doc = " This calls fuse_lowlevel_notify_inval_inode internally."]
    #[doc = ""]
    #[doc = " @return 0 on successful invalidation, negative error value otherwise."]
    #[doc = "         This routine may return -ENOENT to indicate that there was"]
    #[doc = "         no entry to be invalidated, e.g., because the path has not"]
    #[doc = "         been seen before or has been forgotten; this should not be"]
    #[doc = "         considered to be an error."]
    pub fn fuse_invalidate_path(f: *mut fuse, path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " The real main function"]
    #[doc = ""]
    #[doc = " Do not call this directly, use fuse_main()"]
    pub fn fuse_main_real(
        argc: ::libc::c_int,
        argv: *mut *mut ::libc::c_char,
        op: *const fuse_operations,
        op_size: size_t,
        private_data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Start the cleanup thread when using option \"remember\"."]
    #[doc = ""]
    #[doc = " This is done automatically by fuse_loop_mt()"]
    #[doc = " @param fuse struct fuse pointer for fuse instance"]
    #[doc = " @return 0 on success and -1 on error"]
    pub fn fuse_start_cleanup_thread(fuse: *mut fuse) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Stop the cleanup thread when using option \"remember\"."]
    #[doc = ""]
    #[doc = " This is done automatically by fuse_loop_mt()"]
    #[doc = " @param fuse struct fuse pointer for fuse instance"]
    pub fn fuse_stop_cleanup_thread(fuse: *mut fuse);
}
extern "C" {
    #[doc = " Iterate over cache removing stale entries"]
    #[doc = " use in conjunction with \"-oremember\""]
    #[doc = ""]
    #[doc = " NOTE: This is already done for the standard sessions"]
    #[doc = ""]
    #[doc = " @param fuse struct fuse pointer for fuse instance"]
    #[doc = " @return the number of seconds until the next cleanup"]
    pub fn fuse_clean_cache(fuse: *mut fuse) -> ::libc::c_int;
}
#[doc = " Fuse filesystem object"]
#[doc = ""]
#[doc = " This is opaque object represents a filesystem layer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_fs {
    _unused: [u8; 0],
}
extern "C" {
    pub fn fuse_fs_getattr(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *mut stat,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_rename(
        fs: *mut fuse_fs,
        oldpath: *const ::libc::c_char,
        newpath: *const ::libc::c_char,
        flags: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_unlink(fs: *mut fuse_fs, path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_rmdir(fs: *mut fuse_fs, path: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_symlink(
        fs: *mut fuse_fs,
        linkname: *const ::libc::c_char,
        path: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_link(
        fs: *mut fuse_fs,
        oldpath: *const ::libc::c_char,
        newpath: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_release(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_open(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_read(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *mut ::libc::c_char,
        size: size_t,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_read_buf(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        bufp: *mut *mut fuse_bufvec,
        size: size_t,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_write(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *const ::libc::c_char,
        size: size_t,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_write_buf(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *mut fuse_bufvec,
        off: off_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_fsync(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        datasync: ::libc::c_int,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_flush(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_statfs(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *mut statvfs,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_opendir(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_readdir(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *mut ::libc::c_void,
        filler: fuse_fill_dir_t,
        off: off_t,
        fi: *mut fuse_file_info,
        flags: fuse_readdir_flags,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_fsyncdir(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        datasync: ::libc::c_int,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_releasedir(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_create(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        mode: mode_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_lock(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
        cmd: ::libc::c_int,
        lock: *mut flock,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_flock(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
        op: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_chmod(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        mode: mode_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_chown(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        uid: uid_t,
        gid: gid_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_truncate(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        size: off_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_utimens(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        tv: *const timespec,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_access(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        mask: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_readlink(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        buf: *mut ::libc::c_char,
        len: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_mknod(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        mode: mode_t,
        rdev: dev_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_mkdir(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        mode: mode_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_setxattr(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
        size: size_t,
        flags: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_getxattr(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        name: *const ::libc::c_char,
        value: *mut ::libc::c_char,
        size: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_listxattr(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        list: *mut ::libc::c_char,
        size: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_removexattr(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        name: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_bmap(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        blocksize: size_t,
        idx: *mut u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_ioctl(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        cmd: ::libc::c_uint,
        arg: *mut ::libc::c_void,
        fi: *mut fuse_file_info,
        flags: ::libc::c_uint,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_poll(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        fi: *mut fuse_file_info,
        ph: *mut fuse_pollhandle,
        reventsp: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_fallocate(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        mode: ::libc::c_int,
        offset: off_t,
        length: off_t,
        fi: *mut fuse_file_info,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fuse_fs_copy_file_range(
        fs: *mut fuse_fs,
        path_in: *const ::libc::c_char,
        fi_in: *mut fuse_file_info,
        off_in: off_t,
        path_out: *const ::libc::c_char,
        fi_out: *mut fuse_file_info,
        off_out: off_t,
        len: size_t,
        flags: ::libc::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn fuse_fs_lseek(
        fs: *mut fuse_fs,
        path: *const ::libc::c_char,
        off: off_t,
        whence: ::libc::c_int,
        fi: *mut fuse_file_info,
    ) -> off_t;
}
extern "C" {
    pub fn fuse_fs_init(fs: *mut fuse_fs, conn: *mut fuse_conn_info, cfg: *mut fuse_config);
}
extern "C" {
    pub fn fuse_fs_destroy(fs: *mut fuse_fs);
}
extern "C" {
    pub fn fuse_notify_poll(ph: *mut fuse_pollhandle) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Create a new fuse filesystem object"]
    #[doc = ""]
    #[doc = " This is usually called from the factory of a fuse module to create"]
    #[doc = " a new instance of a filesystem."]
    #[doc = ""]
    #[doc = " @param op the filesystem operations"]
    #[doc = " @param op_size the size of the fuse_operations structure"]
    #[doc = " @param private_data Initial value for the `private_data`"]
    #[doc = "            field of `struct fuse_context`. May be overridden by the"]
    #[doc = "            `struct fuse_operations.init` handler."]
    #[doc = " @return a new filesystem object"]
    pub fn fuse_fs_new(
        op: *const fuse_operations,
        op_size: size_t,
        private_data: *mut ::libc::c_void,
    ) -> *mut fuse_fs;
}
#[doc = " Factory for creating filesystem objects"]
#[doc = ""]
#[doc = " The function may use and remove options from 'args' that belong"]
#[doc = " to this module."]
#[doc = ""]
#[doc = " For now the 'fs' vector always contains exactly one filesystem."]
#[doc = " This is the filesystem which will be below the newly created"]
#[doc = " filesystem in the stack."]
#[doc = ""]
#[doc = " @param args the command line arguments"]
#[doc = " @param fs NULL terminated filesystem object vector"]
#[doc = " @return the new filesystem object"]
pub type fuse_module_factory_t = ::std::option::Option<
    unsafe extern "C" fn(args: *mut fuse_args, fs: *mut *mut fuse_fs) -> *mut fuse_fs,
>;
extern "C" {
    #[doc = " Get session from fuse object"]
    pub fn fuse_get_session(f: *mut fuse) -> *mut fuse_session;
}
extern "C" {
    #[doc = " Open a FUSE file descriptor and set up the mount for the given"]
    #[doc = " mountpoint and flags."]
    #[doc = ""]
    #[doc = " @param mountpoint reference to the mount in the file system"]
    #[doc = " @param options mount options"]
    #[doc = " @return the FUSE file descriptor or -1 upon error"]
    pub fn fuse_open_channel(
        mountpoint: *const ::libc::c_char,
        options: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_attr {
    pub ino: u64,
    pub size: u64,
    pub blocks: u64,
    pub atime: u64,
    pub mtime: u64,
    pub ctime: u64,
    pub atimensec: u32,
    pub mtimensec: u32,
    pub ctimensec: u32,
    pub mode: u32,
    pub nlink: u32,
    pub uid: u32,
    pub gid: u32,
    pub rdev: u32,
    pub blksize: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_attr() {
    assert_eq!(
        ::std::mem::size_of::<fuse_attr>(),
        88usize,
        concat!("Size of: ", stringify!(fuse_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_attr))
    );
    fn test_field_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(ino)
            )
        );
    }
    test_field_ino();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(blocks)
            )
        );
    }
    test_field_blocks();
    fn test_field_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(atime)
            )
        );
    }
    test_field_atime();
    fn test_field_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(mtime)
            )
        );
    }
    test_field_mtime();
    fn test_field_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(ctime)
            )
        );
    }
    test_field_ctime();
    fn test_field_atimensec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atimensec) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(atimensec)
            )
        );
    }
    test_field_atimensec();
    fn test_field_mtimensec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mtimensec) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(mtimensec)
            )
        );
    }
    test_field_mtimensec();
    fn test_field_ctimensec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctimensec) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(ctimensec)
            )
        );
    }
    test_field_ctimensec();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlink) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(nlink)
            )
        );
    }
    test_field_nlink();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(gid)
            )
        );
    }
    test_field_gid();
    fn test_field_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdev) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(rdev)
            )
        );
    }
    test_field_rdev();
    fn test_field_blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blksize) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(blksize)
            )
        );
    }
    test_field_blksize();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_kstatfs {
    pub blocks: u64,
    pub bfree: u64,
    pub bavail: u64,
    pub files: u64,
    pub ffree: u64,
    pub bsize: u32,
    pub namelen: u32,
    pub frsize: u32,
    pub padding: u32,
    pub spare: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_fuse_kstatfs() {
    assert_eq!(
        ::std::mem::size_of::<fuse_kstatfs>(),
        80usize,
        concat!("Size of: ", stringify!(fuse_kstatfs))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_kstatfs>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_kstatfs))
    );
    fn test_field_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(blocks)
            )
        );
    }
    test_field_blocks();
    fn test_field_bfree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bfree) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(bfree)
            )
        );
    }
    test_field_bfree();
    fn test_field_bavail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bavail) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(bavail)
            )
        );
    }
    test_field_bavail();
    fn test_field_files() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).files) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(files)
            )
        );
    }
    test_field_files();
    fn test_field_ffree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ffree) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(ffree)
            )
        );
    }
    test_field_ffree();
    fn test_field_bsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(bsize)
            )
        );
    }
    test_field_bsize();
    fn test_field_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(namelen)
            )
        );
    }
    test_field_namelen();
    fn test_field_frsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frsize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(frsize)
            )
        );
    }
    test_field_frsize();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
    fn test_field_spare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_kstatfs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spare) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_kstatfs),
                "::",
                stringify!(spare)
            )
        );
    }
    test_field_spare();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_file_lock {
    pub start: u64,
    pub end: u64,
    pub type_: u32,
    pub pid: u32,
}
#[test]
fn bindgen_test_layout_fuse_file_lock() {
    assert_eq!(
        ::std::mem::size_of::<fuse_file_lock>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_file_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_file_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_file_lock))
    );
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_lock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_lock),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_lock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_lock),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_lock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_lock),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_file_lock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_file_lock),
                "::",
                stringify!(pid)
            )
        );
    }
    test_field_pid();
}
pub const fuse_opcode_FUSE_LOOKUP: fuse_opcode = 1;
pub const fuse_opcode_FUSE_FORGET: fuse_opcode = 2;
pub const fuse_opcode_FUSE_GETATTR: fuse_opcode = 3;
pub const fuse_opcode_FUSE_SETATTR: fuse_opcode = 4;
pub const fuse_opcode_FUSE_READLINK: fuse_opcode = 5;
pub const fuse_opcode_FUSE_SYMLINK: fuse_opcode = 6;
pub const fuse_opcode_FUSE_MKNOD: fuse_opcode = 8;
pub const fuse_opcode_FUSE_MKDIR: fuse_opcode = 9;
pub const fuse_opcode_FUSE_UNLINK: fuse_opcode = 10;
pub const fuse_opcode_FUSE_RMDIR: fuse_opcode = 11;
pub const fuse_opcode_FUSE_RENAME: fuse_opcode = 12;
pub const fuse_opcode_FUSE_LINK: fuse_opcode = 13;
pub const fuse_opcode_FUSE_OPEN: fuse_opcode = 14;
pub const fuse_opcode_FUSE_READ: fuse_opcode = 15;
pub const fuse_opcode_FUSE_WRITE: fuse_opcode = 16;
pub const fuse_opcode_FUSE_STATFS: fuse_opcode = 17;
pub const fuse_opcode_FUSE_RELEASE: fuse_opcode = 18;
pub const fuse_opcode_FUSE_FSYNC: fuse_opcode = 20;
pub const fuse_opcode_FUSE_SETXATTR: fuse_opcode = 21;
pub const fuse_opcode_FUSE_GETXATTR: fuse_opcode = 22;
pub const fuse_opcode_FUSE_LISTXATTR: fuse_opcode = 23;
pub const fuse_opcode_FUSE_REMOVEXATTR: fuse_opcode = 24;
pub const fuse_opcode_FUSE_FLUSH: fuse_opcode = 25;
pub const fuse_opcode_FUSE_INIT: fuse_opcode = 26;
pub const fuse_opcode_FUSE_OPENDIR: fuse_opcode = 27;
pub const fuse_opcode_FUSE_READDIR: fuse_opcode = 28;
pub const fuse_opcode_FUSE_RELEASEDIR: fuse_opcode = 29;
pub const fuse_opcode_FUSE_FSYNCDIR: fuse_opcode = 30;
pub const fuse_opcode_FUSE_GETLK: fuse_opcode = 31;
pub const fuse_opcode_FUSE_SETLK: fuse_opcode = 32;
pub const fuse_opcode_FUSE_SETLKW: fuse_opcode = 33;
pub const fuse_opcode_FUSE_ACCESS: fuse_opcode = 34;
pub const fuse_opcode_FUSE_CREATE: fuse_opcode = 35;
pub const fuse_opcode_FUSE_INTERRUPT: fuse_opcode = 36;
pub const fuse_opcode_FUSE_BMAP: fuse_opcode = 37;
pub const fuse_opcode_FUSE_DESTROY: fuse_opcode = 38;
pub const fuse_opcode_FUSE_IOCTL: fuse_opcode = 39;
pub const fuse_opcode_FUSE_POLL: fuse_opcode = 40;
pub const fuse_opcode_FUSE_NOTIFY_REPLY: fuse_opcode = 41;
pub const fuse_opcode_FUSE_BATCH_FORGET: fuse_opcode = 42;
pub const fuse_opcode_FUSE_FALLOCATE: fuse_opcode = 43;
pub const fuse_opcode_FUSE_READDIRPLUS: fuse_opcode = 44;
pub const fuse_opcode_FUSE_RENAME2: fuse_opcode = 45;
pub const fuse_opcode_FUSE_LSEEK: fuse_opcode = 46;
pub const fuse_opcode_FUSE_COPY_FILE_RANGE: fuse_opcode = 47;
pub const fuse_opcode_CUSE_INIT: fuse_opcode = 4096;
pub type fuse_opcode = ::libc::c_uint;
pub const fuse_notify_code_FUSE_NOTIFY_POLL: fuse_notify_code = 1;
pub const fuse_notify_code_FUSE_NOTIFY_INVAL_INODE: fuse_notify_code = 2;
pub const fuse_notify_code_FUSE_NOTIFY_INVAL_ENTRY: fuse_notify_code = 3;
pub const fuse_notify_code_FUSE_NOTIFY_STORE: fuse_notify_code = 4;
pub const fuse_notify_code_FUSE_NOTIFY_RETRIEVE: fuse_notify_code = 5;
pub const fuse_notify_code_FUSE_NOTIFY_DELETE: fuse_notify_code = 6;
pub const fuse_notify_code_FUSE_NOTIFY_CODE_MAX: fuse_notify_code = 7;
pub type fuse_notify_code = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_entry_out {
    pub nodeid: u64,
    pub generation: u64,
    pub entry_valid: u64,
    pub attr_valid: u64,
    pub entry_valid_nsec: u32,
    pub attr_valid_nsec: u32,
    pub attr: fuse_attr,
}
#[test]
fn bindgen_test_layout_fuse_entry_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_entry_out>(),
        128usize,
        concat!("Size of: ", stringify!(fuse_entry_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_entry_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_entry_out))
    );
    fn test_field_nodeid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(nodeid)
            )
        );
    }
    test_field_nodeid();
    fn test_field_generation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).generation) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(generation)
            )
        );
    }
    test_field_generation();
    fn test_field_entry_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_valid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(entry_valid)
            )
        );
    }
    test_field_entry_valid();
    fn test_field_attr_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr_valid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(attr_valid)
            )
        );
    }
    test_field_attr_valid();
    fn test_field_entry_valid_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_valid_nsec) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(entry_valid_nsec)
            )
        );
    }
    test_field_entry_valid_nsec();
    fn test_field_attr_valid_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr_valid_nsec) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(attr_valid_nsec)
            )
        );
    }
    test_field_attr_valid_nsec();
    fn test_field_attr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_entry_out),
                "::",
                stringify!(attr)
            )
        );
    }
    test_field_attr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_forget_in {
    pub nlookup: u64,
}
#[test]
fn bindgen_test_layout_fuse_forget_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_forget_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_forget_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_forget_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_forget_in))
    );
    fn test_field_nlookup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_forget_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlookup) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_forget_in),
                "::",
                stringify!(nlookup)
            )
        );
    }
    test_field_nlookup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_forget_one {
    pub nodeid: u64,
    pub nlookup: u64,
}
#[test]
fn bindgen_test_layout_fuse_forget_one() {
    assert_eq!(
        ::std::mem::size_of::<fuse_forget_one>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_forget_one))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_forget_one>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_forget_one))
    );
    fn test_field_nodeid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_forget_one>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_forget_one),
                "::",
                stringify!(nodeid)
            )
        );
    }
    test_field_nodeid();
    fn test_field_nlookup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_forget_one>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlookup) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_forget_one),
                "::",
                stringify!(nlookup)
            )
        );
    }
    test_field_nlookup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_batch_forget_in {
    pub count: u32,
    pub dummy: u32,
}
#[test]
fn bindgen_test_layout_fuse_batch_forget_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_batch_forget_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_batch_forget_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_batch_forget_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_batch_forget_in))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_batch_forget_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_batch_forget_in),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_batch_forget_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_batch_forget_in),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_getattr_in {
    pub getattr_flags: u32,
    pub dummy: u32,
    pub fh: u64,
}
#[test]
fn bindgen_test_layout_fuse_getattr_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_getattr_in>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_getattr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_getattr_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_getattr_in))
    );
    fn test_field_getattr_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).getattr_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getattr_in),
                "::",
                stringify!(getattr_flags)
            )
        );
    }
    test_field_getattr_flags();
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getattr_in),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getattr_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_attr_out {
    pub attr_valid: u64,
    pub attr_valid_nsec: u32,
    pub dummy: u32,
    pub attr: fuse_attr,
}
#[test]
fn bindgen_test_layout_fuse_attr_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_attr_out>(),
        104usize,
        concat!("Size of: ", stringify!(fuse_attr_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_attr_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_attr_out))
    );
    fn test_field_attr_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr_valid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr_out),
                "::",
                stringify!(attr_valid)
            )
        );
    }
    test_field_attr_valid();
    fn test_field_attr_valid_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr_valid_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr_out),
                "::",
                stringify!(attr_valid_nsec)
            )
        );
    }
    test_field_attr_valid_nsec();
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr_out),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
    fn test_field_attr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_attr_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_attr_out),
                "::",
                stringify!(attr)
            )
        );
    }
    test_field_attr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_mknod_in {
    pub mode: u32,
    pub rdev: u32,
    pub umask: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_mknod_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_mknod_in>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_mknod_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_mknod_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_mknod_in))
    );
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_mknod_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_mknod_in),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_mknod_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdev) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_mknod_in),
                "::",
                stringify!(rdev)
            )
        );
    }
    test_field_rdev();
    fn test_field_umask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_mknod_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_mknod_in),
                "::",
                stringify!(umask)
            )
        );
    }
    test_field_umask();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_mknod_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_mknod_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_mkdir_in {
    pub mode: u32,
    pub umask: u32,
}
#[test]
fn bindgen_test_layout_fuse_mkdir_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_mkdir_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_mkdir_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_mkdir_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_mkdir_in))
    );
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_mkdir_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_mkdir_in),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_umask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_mkdir_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_mkdir_in),
                "::",
                stringify!(umask)
            )
        );
    }
    test_field_umask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_rename_in {
    pub newdir: u64,
}
#[test]
fn bindgen_test_layout_fuse_rename_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_rename_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_rename_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_rename_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_rename_in))
    );
    fn test_field_newdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_rename_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newdir) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_rename_in),
                "::",
                stringify!(newdir)
            )
        );
    }
    test_field_newdir();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_rename2_in {
    pub newdir: u64,
    pub flags: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_rename2_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_rename2_in>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_rename2_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_rename2_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_rename2_in))
    );
    fn test_field_newdir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_rename2_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newdir) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_rename2_in),
                "::",
                stringify!(newdir)
            )
        );
    }
    test_field_newdir();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_rename2_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_rename2_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_rename2_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_rename2_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_link_in {
    pub oldnodeid: u64,
}
#[test]
fn bindgen_test_layout_fuse_link_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_link_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_link_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_link_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_link_in))
    );
    fn test_field_oldnodeid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_link_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldnodeid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_link_in),
                "::",
                stringify!(oldnodeid)
            )
        );
    }
    test_field_oldnodeid();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_setattr_in {
    pub valid: u32,
    pub padding: u32,
    pub fh: u64,
    pub size: u64,
    pub lock_owner: u64,
    pub atime: u64,
    pub mtime: u64,
    pub ctime: u64,
    pub atimensec: u32,
    pub mtimensec: u32,
    pub ctimensec: u32,
    pub mode: u32,
    pub unused4: u32,
    pub uid: u32,
    pub gid: u32,
    pub unused5: u32,
}
#[test]
fn bindgen_test_layout_fuse_setattr_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_setattr_in>(),
        88usize,
        concat!("Size of: ", stringify!(fuse_setattr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_setattr_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_setattr_in))
    );
    fn test_field_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(valid)
            )
        );
    }
    test_field_valid();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
    fn test_field_atime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atime) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(atime)
            )
        );
    }
    test_field_atime();
    fn test_field_mtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(mtime)
            )
        );
    }
    test_field_mtime();
    fn test_field_ctime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctime) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(ctime)
            )
        );
    }
    test_field_ctime();
    fn test_field_atimensec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).atimensec) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(atimensec)
            )
        );
    }
    test_field_atimensec();
    fn test_field_mtimensec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mtimensec) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(mtimensec)
            )
        );
    }
    test_field_mtimensec();
    fn test_field_ctimensec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctimensec) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(ctimensec)
            )
        );
    }
    test_field_ctimensec();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_unused4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused4) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(unused4)
            )
        );
    }
    test_field_unused4();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(gid)
            )
        );
    }
    test_field_gid();
    fn test_field_unused5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused5) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setattr_in),
                "::",
                stringify!(unused5)
            )
        );
    }
    test_field_unused5();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_open_in {
    pub flags: u32,
    pub unused: u32,
}
#[test]
fn bindgen_test_layout_fuse_open_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_open_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_open_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_open_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_open_in))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_open_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_open_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_open_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_open_in),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_create_in {
    pub flags: u32,
    pub mode: u32,
    pub umask: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_create_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_create_in>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_create_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_create_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_create_in))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_create_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_create_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_create_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_create_in),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_umask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_create_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).umask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_create_in),
                "::",
                stringify!(umask)
            )
        );
    }
    test_field_umask();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_create_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_create_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_open_out {
    pub fh: u64,
    pub open_flags: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_open_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_open_out>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_open_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_open_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_open_out))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_open_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_open_out),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_open_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_open_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_open_out),
                "::",
                stringify!(open_flags)
            )
        );
    }
    test_field_open_flags();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_open_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_open_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_release_in {
    pub fh: u64,
    pub flags: u32,
    pub release_flags: u32,
    pub lock_owner: u64,
}
#[test]
fn bindgen_test_layout_fuse_release_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_release_in>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_release_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_release_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_release_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_release_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_release_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_release_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_release_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_release_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_release_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_release_in),
                "::",
                stringify!(release_flags)
            )
        );
    }
    test_field_release_flags();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_release_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_release_in),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_flush_in {
    pub fh: u64,
    pub unused: u32,
    pub padding: u32,
    pub lock_owner: u64,
}
#[test]
fn bindgen_test_layout_fuse_flush_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_flush_in>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_flush_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_flush_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_flush_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_flush_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_flush_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_flush_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_flush_in),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_flush_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_flush_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_flush_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_flush_in),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_read_in {
    pub fh: u64,
    pub offset: u64,
    pub size: u32,
    pub read_flags: u32,
    pub lock_owner: u64,
    pub flags: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_read_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_read_in>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_read_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_read_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_read_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_read_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(read_flags)
            )
        );
    }
    test_field_read_flags();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_read_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_read_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_write_in {
    pub fh: u64,
    pub offset: u64,
    pub size: u32,
    pub write_flags: u32,
    pub lock_owner: u64,
    pub flags: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_write_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_write_in>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_write_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_write_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_write_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_write_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(write_flags)
            )
        );
    }
    test_field_write_flags();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_write_out {
    pub size: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_write_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_write_out>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_write_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_write_out>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_write_out))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_out),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_write_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_write_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_statfs_out {
    pub st: fuse_kstatfs,
}
#[test]
fn bindgen_test_layout_fuse_statfs_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_statfs_out>(),
        80usize,
        concat!("Size of: ", stringify!(fuse_statfs_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_statfs_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_statfs_out))
    );
    fn test_field_st() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_statfs_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_statfs_out),
                "::",
                stringify!(st)
            )
        );
    }
    test_field_st();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_fsync_in {
    pub fh: u64,
    pub fsync_flags: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_fsync_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_fsync_in>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_fsync_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_fsync_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_fsync_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fsync_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fsync_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_fsync_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fsync_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsync_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fsync_in),
                "::",
                stringify!(fsync_flags)
            )
        );
    }
    test_field_fsync_flags();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fsync_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fsync_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_setxattr_in {
    pub size: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_fuse_setxattr_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_setxattr_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_setxattr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_setxattr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_setxattr_in))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setxattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setxattr_in),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_setxattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_setxattr_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_getxattr_in {
    pub size: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_getxattr_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_getxattr_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_getxattr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_getxattr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_getxattr_in))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getxattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getxattr_in),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getxattr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getxattr_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_getxattr_out {
    pub size: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_getxattr_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_getxattr_out>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_getxattr_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_getxattr_out>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_getxattr_out))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getxattr_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getxattr_out),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_getxattr_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_getxattr_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_lk_in {
    pub fh: u64,
    pub owner: u64,
    pub lk: fuse_file_lock,
    pub lk_flags: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_lk_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_lk_in>(),
        48usize,
        concat!("Size of: ", stringify!(fuse_lk_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_lk_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_lk_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lk_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lk_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lk_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lk_in),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
    fn test_field_lk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lk_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lk) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lk_in),
                "::",
                stringify!(lk)
            )
        );
    }
    test_field_lk();
    fn test_field_lk_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lk_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lk_flags) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lk_in),
                "::",
                stringify!(lk_flags)
            )
        );
    }
    test_field_lk_flags();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lk_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lk_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_lk_out {
    pub lk: fuse_file_lock,
}
#[test]
fn bindgen_test_layout_fuse_lk_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_lk_out>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_lk_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_lk_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_lk_out))
    );
    fn test_field_lk() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lk_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lk) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lk_out),
                "::",
                stringify!(lk)
            )
        );
    }
    test_field_lk();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_access_in {
    pub mask: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_access_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_access_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_access_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_access_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_access_in))
    );
    fn test_field_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_access_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_access_in),
                "::",
                stringify!(mask)
            )
        );
    }
    test_field_mask();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_access_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_access_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_init_in {
    pub major: u32,
    pub minor: u32,
    pub max_readahead: u32,
    pub flags: u32,
    pub flags2: u32,
    pub unused: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_fuse_init_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_init_in>(),
        64usize,
        concat!("Size of: ", stringify!(fuse_init_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_init_in>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_init_in))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_in),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_in),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_max_readahead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_readahead) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_in),
                "::",
                stringify!(max_readahead)
            )
        );
    }
    test_field_max_readahead();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_in),
                "::",
                stringify!(flags2)
            )
        );
    }
    test_field_flags2();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_in),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_init_out {
    pub major: u32,
    pub minor: u32,
    pub max_readahead: u32,
    pub flags: u32,
    pub max_background: u16,
    pub congestion_threshold: u16,
    pub max_write: u32,
    pub time_gran: u32,
    pub max_pages: u16,
    pub map_alignment: u16,
    pub flags2: u32,
    pub unused: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_fuse_init_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_init_out>(),
        64usize,
        concat!("Size of: ", stringify!(fuse_init_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_init_out>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_init_out))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_max_readahead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_readahead) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(max_readahead)
            )
        );
    }
    test_field_max_readahead();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_max_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_background) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(max_background)
            )
        );
    }
    test_field_max_background();
    fn test_field_congestion_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).congestion_threshold) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(congestion_threshold)
            )
        );
    }
    test_field_congestion_threshold();
    fn test_field_max_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_write) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(max_write)
            )
        );
    }
    test_field_max_write();
    fn test_field_time_gran() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time_gran) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(time_gran)
            )
        );
    }
    test_field_time_gran();
    fn test_field_max_pages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_pages) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(max_pages)
            )
        );
    }
    test_field_max_pages();
    fn test_field_map_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).map_alignment) as usize - ptr as usize
            },
            30usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(map_alignment)
            )
        );
    }
    test_field_map_alignment();
    fn test_field_flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags2) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(flags2)
            )
        );
    }
    test_field_flags2();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_init_out),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cuse_init_in {
    pub major: u32,
    pub minor: u32,
    pub unused: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_cuse_init_in() {
    assert_eq!(
        ::std::mem::size_of::<cuse_init_in>(),
        16usize,
        concat!("Size of: ", stringify!(cuse_init_in))
    );
    assert_eq!(
        ::std::mem::align_of::<cuse_init_in>(),
        4usize,
        concat!("Alignment of ", stringify!(cuse_init_in))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_in),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_in),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_in),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cuse_init_out {
    pub major: u32,
    pub minor: u32,
    pub unused: u32,
    pub flags: u32,
    pub max_read: u32,
    pub max_write: u32,
    pub dev_major: u32,
    pub dev_minor: u32,
    pub spare: [u32; 10usize],
}
#[test]
fn bindgen_test_layout_cuse_init_out() {
    assert_eq!(
        ::std::mem::size_of::<cuse_init_out>(),
        72usize,
        concat!("Size of: ", stringify!(cuse_init_out))
    );
    assert_eq!(
        ::std::mem::align_of::<cuse_init_out>(),
        4usize,
        concat!("Alignment of ", stringify!(cuse_init_out))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(unused)
            )
        );
    }
    test_field_unused();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_max_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_read) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(max_read)
            )
        );
    }
    test_field_max_read();
    fn test_field_max_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_write) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(max_write)
            )
        );
    }
    test_field_max_write();
    fn test_field_dev_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_major) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(dev_major)
            )
        );
    }
    test_field_dev_major();
    fn test_field_dev_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_minor) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(dev_minor)
            )
        );
    }
    test_field_dev_minor();
    fn test_field_spare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cuse_init_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spare) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(cuse_init_out),
                "::",
                stringify!(spare)
            )
        );
    }
    test_field_spare();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_interrupt_in {
    pub unique: u64,
}
#[test]
fn bindgen_test_layout_fuse_interrupt_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_interrupt_in>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_interrupt_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_interrupt_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_interrupt_in))
    );
    fn test_field_unique() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_interrupt_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unique) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_interrupt_in),
                "::",
                stringify!(unique)
            )
        );
    }
    test_field_unique();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_bmap_in {
    pub block: u64,
    pub blocksize: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_bmap_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_bmap_in>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_bmap_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_bmap_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_bmap_in))
    );
    fn test_field_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bmap_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bmap_in),
                "::",
                stringify!(block)
            )
        );
    }
    test_field_block();
    fn test_field_blocksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bmap_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blocksize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bmap_in),
                "::",
                stringify!(blocksize)
            )
        );
    }
    test_field_blocksize();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bmap_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bmap_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_bmap_out {
    pub block: u64,
}
#[test]
fn bindgen_test_layout_fuse_bmap_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_bmap_out>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_bmap_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_bmap_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_bmap_out))
    );
    fn test_field_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_bmap_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_bmap_out),
                "::",
                stringify!(block)
            )
        );
    }
    test_field_block();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_ioctl_in {
    pub fh: u64,
    pub flags: u32,
    pub cmd: u32,
    pub arg: u64,
    pub in_size: u32,
    pub out_size: u32,
}
#[test]
fn bindgen_test_layout_fuse_ioctl_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_ioctl_in>(),
        32usize,
        concat!("Size of: ", stringify!(fuse_ioctl_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_ioctl_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_ioctl_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_in),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
    fn test_field_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_in),
                "::",
                stringify!(arg)
            )
        );
    }
    test_field_arg();
    fn test_field_in_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).in_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_in),
                "::",
                stringify!(in_size)
            )
        );
    }
    test_field_in_size();
    fn test_field_out_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).out_size) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_in),
                "::",
                stringify!(out_size)
            )
        );
    }
    test_field_out_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_ioctl_iovec {
    pub base: u64,
    pub len: u64,
}
#[test]
fn bindgen_test_layout_fuse_ioctl_iovec() {
    assert_eq!(
        ::std::mem::size_of::<fuse_ioctl_iovec>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_ioctl_iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_ioctl_iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_ioctl_iovec))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_iovec),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_iovec),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_ioctl_out {
    pub result: i32,
    pub flags: u32,
    pub in_iovs: u32,
    pub out_iovs: u32,
}
#[test]
fn bindgen_test_layout_fuse_ioctl_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_ioctl_out>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_ioctl_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_ioctl_out>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_ioctl_out))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_out),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_out),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_in_iovs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).in_iovs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_out),
                "::",
                stringify!(in_iovs)
            )
        );
    }
    test_field_in_iovs();
    fn test_field_out_iovs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_ioctl_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).out_iovs) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_ioctl_out),
                "::",
                stringify!(out_iovs)
            )
        );
    }
    test_field_out_iovs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_poll_in {
    pub fh: u64,
    pub kh: u64,
    pub flags: u32,
    pub events: u32,
}
#[test]
fn bindgen_test_layout_fuse_poll_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_poll_in>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_poll_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_poll_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_poll_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_poll_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_poll_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_kh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_poll_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kh) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_poll_in),
                "::",
                stringify!(kh)
            )
        );
    }
    test_field_kh();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_poll_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_poll_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_poll_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_poll_in),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_poll_out {
    pub revents: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_poll_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_poll_out>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_poll_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_poll_out>(),
        4usize,
        concat!("Alignment of ", stringify!(fuse_poll_out))
    );
    fn test_field_revents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_poll_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_poll_out),
                "::",
                stringify!(revents)
            )
        );
    }
    test_field_revents();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_poll_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_poll_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_poll_wakeup_out {
    pub kh: u64,
}
#[test]
fn bindgen_test_layout_fuse_notify_poll_wakeup_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_poll_wakeup_out>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_notify_poll_wakeup_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_poll_wakeup_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_poll_wakeup_out))
    );
    fn test_field_kh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_poll_wakeup_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_poll_wakeup_out),
                "::",
                stringify!(kh)
            )
        );
    }
    test_field_kh();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_fallocate_in {
    pub fh: u64,
    pub offset: u64,
    pub length: u64,
    pub mode: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_fallocate_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_fallocate_in>(),
        32usize,
        concat!("Size of: ", stringify!(fuse_fallocate_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_fallocate_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_fallocate_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fallocate_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fallocate_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fallocate_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fallocate_in),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fallocate_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fallocate_in),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fallocate_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fallocate_in),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_fallocate_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_fallocate_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_in_header {
    pub len: u32,
    pub opcode: u32,
    pub unique: u64,
    pub nodeid: u64,
    pub uid: u32,
    pub gid: u32,
    pub pid: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_in_header() {
    assert_eq!(
        ::std::mem::size_of::<fuse_in_header>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_in_header))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_in_header>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_in_header))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_opcode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(opcode)
            )
        );
    }
    test_field_opcode();
    fn test_field_unique() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unique) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(unique)
            )
        );
    }
    test_field_unique();
    fn test_field_nodeid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(nodeid)
            )
        );
    }
    test_field_nodeid();
    fn test_field_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(uid)
            )
        );
    }
    test_field_uid();
    fn test_field_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gid) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(gid)
            )
        );
    }
    test_field_gid();
    fn test_field_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pid) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(pid)
            )
        );
    }
    test_field_pid();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_in_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_in_header),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_out_header {
    pub len: u32,
    pub error: i32,
    pub unique: u64,
}
#[test]
fn bindgen_test_layout_fuse_out_header() {
    assert_eq!(
        ::std::mem::size_of::<fuse_out_header>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_out_header))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_out_header>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_out_header))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_out_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_out_header),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_out_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_out_header),
                "::",
                stringify!(error)
            )
        );
    }
    test_field_error();
    fn test_field_unique() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_out_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unique) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_out_header),
                "::",
                stringify!(unique)
            )
        );
    }
    test_field_unique();
}
#[repr(C)]
#[derive(Debug)]
pub struct fuse_dirent {
    pub ino: u64,
    pub off: u64,
    pub namelen: u32,
    pub type_: u32,
    pub name: __IncompleteArrayField<::libc::c_char>,
}
#[test]
fn bindgen_test_layout_fuse_dirent() {
    assert_eq!(
        ::std::mem::size_of::<fuse_dirent>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_dirent))
    );
    fn test_field_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_dirent),
                "::",
                stringify!(ino)
            )
        );
    }
    test_field_ino();
    fn test_field_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_dirent),
                "::",
                stringify!(off)
            )
        );
    }
    test_field_off();
    fn test_field_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_dirent),
                "::",
                stringify!(namelen)
            )
        );
    }
    test_field_namelen();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_dirent),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_dirent),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
}
#[repr(C)]
#[derive(Debug)]
pub struct fuse_direntplus {
    pub entry_out: fuse_entry_out,
    pub dirent: fuse_dirent,
}
#[test]
fn bindgen_test_layout_fuse_direntplus() {
    assert_eq!(
        ::std::mem::size_of::<fuse_direntplus>(),
        152usize,
        concat!("Size of: ", stringify!(fuse_direntplus))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_direntplus>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_direntplus))
    );
    fn test_field_entry_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_direntplus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_out) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_direntplus),
                "::",
                stringify!(entry_out)
            )
        );
    }
    test_field_entry_out();
    fn test_field_dirent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_direntplus>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dirent) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_direntplus),
                "::",
                stringify!(dirent)
            )
        );
    }
    test_field_dirent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_inval_inode_out {
    pub ino: u64,
    pub off: i64,
    pub len: i64,
}
#[test]
fn bindgen_test_layout_fuse_notify_inval_inode_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_inval_inode_out>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_notify_inval_inode_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_inval_inode_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_inval_inode_out))
    );
    fn test_field_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_inval_inode_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_inval_inode_out),
                "::",
                stringify!(ino)
            )
        );
    }
    test_field_ino();
    fn test_field_off() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_inval_inode_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_inval_inode_out),
                "::",
                stringify!(off)
            )
        );
    }
    test_field_off();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_inval_inode_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_inval_inode_out),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_inval_entry_out {
    pub parent: u64,
    pub namelen: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_notify_inval_entry_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_inval_entry_out>(),
        16usize,
        concat!("Size of: ", stringify!(fuse_notify_inval_entry_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_inval_entry_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_inval_entry_out))
    );
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_inval_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_inval_entry_out),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_inval_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_inval_entry_out),
                "::",
                stringify!(namelen)
            )
        );
    }
    test_field_namelen();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_inval_entry_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_inval_entry_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_delete_out {
    pub parent: u64,
    pub child: u64,
    pub namelen: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_notify_delete_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_delete_out>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_notify_delete_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_delete_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_delete_out))
    );
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_delete_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_delete_out),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_child() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_delete_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_delete_out),
                "::",
                stringify!(child)
            )
        );
    }
    test_field_child();
    fn test_field_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_delete_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namelen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_delete_out),
                "::",
                stringify!(namelen)
            )
        );
    }
    test_field_namelen();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_delete_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_delete_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_store_out {
    pub nodeid: u64,
    pub offset: u64,
    pub size: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_notify_store_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_store_out>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_notify_store_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_store_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_store_out))
    );
    fn test_field_nodeid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_store_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_store_out),
                "::",
                stringify!(nodeid)
            )
        );
    }
    test_field_nodeid();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_store_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_store_out),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_store_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_store_out),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_store_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_store_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_retrieve_out {
    pub notify_unique: u64,
    pub nodeid: u64,
    pub offset: u64,
    pub size: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_notify_retrieve_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_retrieve_out>(),
        32usize,
        concat!("Size of: ", stringify!(fuse_notify_retrieve_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_retrieve_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_retrieve_out))
    );
    fn test_field_notify_unique() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify_unique) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_out),
                "::",
                stringify!(notify_unique)
            )
        );
    }
    test_field_notify_unique();
    fn test_field_nodeid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_out),
                "::",
                stringify!(nodeid)
            )
        );
    }
    test_field_nodeid();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_out),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_out),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_out),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_notify_retrieve_in {
    pub dummy1: u64,
    pub offset: u64,
    pub size: u32,
    pub dummy2: u32,
    pub dummy3: u64,
    pub dummy4: u64,
}
#[test]
fn bindgen_test_layout_fuse_notify_retrieve_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_notify_retrieve_in>(),
        40usize,
        concat!("Size of: ", stringify!(fuse_notify_retrieve_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_notify_retrieve_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_notify_retrieve_in))
    );
    fn test_field_dummy1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_in),
                "::",
                stringify!(dummy1)
            )
        );
    }
    test_field_dummy1();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_in),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_in),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_dummy2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_in),
                "::",
                stringify!(dummy2)
            )
        );
    }
    test_field_dummy2();
    fn test_field_dummy3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_in),
                "::",
                stringify!(dummy3)
            )
        );
    }
    test_field_dummy3();
    fn test_field_dummy4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_notify_retrieve_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_notify_retrieve_in),
                "::",
                stringify!(dummy4)
            )
        );
    }
    test_field_dummy4();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_lseek_in {
    pub fh: u64,
    pub offset: u64,
    pub whence: u32,
    pub padding: u32,
}
#[test]
fn bindgen_test_layout_fuse_lseek_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_lseek_in>(),
        24usize,
        concat!("Size of: ", stringify!(fuse_lseek_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_lseek_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_lseek_in))
    );
    fn test_field_fh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lseek_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lseek_in),
                "::",
                stringify!(fh)
            )
        );
    }
    test_field_fh();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lseek_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lseek_in),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_whence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lseek_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).whence) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lseek_in),
                "::",
                stringify!(whence)
            )
        );
    }
    test_field_whence();
    fn test_field_padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lseek_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lseek_in),
                "::",
                stringify!(padding)
            )
        );
    }
    test_field_padding();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_lseek_out {
    pub offset: u64,
}
#[test]
fn bindgen_test_layout_fuse_lseek_out() {
    assert_eq!(
        ::std::mem::size_of::<fuse_lseek_out>(),
        8usize,
        concat!("Size of: ", stringify!(fuse_lseek_out))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_lseek_out>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_lseek_out))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_lseek_out>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_lseek_out),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fuse_copy_file_range_in {
    pub fh_in: u64,
    pub off_in: u64,
    pub nodeid_out: u64,
    pub fh_out: u64,
    pub off_out: u64,
    pub len: u64,
    pub flags: u64,
}
#[test]
fn bindgen_test_layout_fuse_copy_file_range_in() {
    assert_eq!(
        ::std::mem::size_of::<fuse_copy_file_range_in>(),
        56usize,
        concat!("Size of: ", stringify!(fuse_copy_file_range_in))
    );
    assert_eq!(
        ::std::mem::align_of::<fuse_copy_file_range_in>(),
        8usize,
        concat!("Alignment of ", stringify!(fuse_copy_file_range_in))
    );
    fn test_field_fh_in() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh_in) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(fh_in)
            )
        );
    }
    test_field_fh_in();
    fn test_field_off_in() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).off_in) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(off_in)
            )
        );
    }
    test_field_off_in();
    fn test_field_nodeid_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeid_out) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(nodeid_out)
            )
        );
    }
    test_field_nodeid_out();
    fn test_field_fh_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fh_out) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(fh_out)
            )
        );
    }
    test_field_fh_out();
    fn test_field_off_out() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).off_out) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(off_out)
            )
        );
    }
    test_field_off_out();
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fuse_copy_file_range_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(fuse_copy_file_range_in),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
